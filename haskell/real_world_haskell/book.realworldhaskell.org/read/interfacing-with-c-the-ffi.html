<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 17. Interfacing with C: the FFI</title><link rel="stylesheet" href="/support/styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Real World Haskell"><link rel="up" href="index.html" title="Real World Haskell"><link rel="prev" href="using-parsec.html" title="Chapter 16. Using Parsec"><link rel="next" href="monad-transformers.html" title="Chapter 18. Monad transformers"><link rel="alternate" type="application/atom+xml" title="Comments" href="/feeds/comments/"><link rel="shortcut icon" type="image/png" href="/support/figs/favicon.png"><script type="text/javascript" src="/support/jquery-min.js"></script><script type="text/javascript" src="/support/form.js"></script><script type="text/javascript" src="/support/hsbook.js"></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 17. Interfacing with C: the FFI</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="using-parsec.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="monad-transformers.html">Next</a></td></tr></table></div><div class="chapter" lang="en" id="ffi"><div class="titlepage"><div><div><h2 class="title">Chapter 17. Interfacing with C: the FFI</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="interfacing-with-c-the-ffi.html#id653815">Foreign language bindings: the basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654076">Be careful of side effects</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654123">A high level wrapper</a></span></dt></dl></dd><dt><span class="sect1"><a href="interfacing-with-c-the-ffi.html#id654294">Regular expressions for Haskell: a binding for PCRE</a></span></dt><dd><dl><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654351">Simple tasks: using the C preprocessor</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654451">
Binding Haskell to C with hsc2hs
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654503">
   Adding type safety to PCRE
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654629">
Binding to constants
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id654840">
Automating the binding
  </a></span></dt></dl></dd><dt><span class="sect1"><a href="interfacing-with-c-the-ffi.html#id654997">Passing string data between Haskell and C</a></span></dt><dd><dl><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655194">
    Typed pointers
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655309">
    Memory management: let the garbage collector do the work
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655462">
    A high level interface: marshalling data
  </a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655555">Mashalling ByteStrings</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655666">Allocating local C data: the Storable class</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id655783">Putting it all together</a></span></dt></dl></dd><dt><span class="sect1"><a href="interfacing-with-c-the-ffi.html#id656122">Matching on strings</a></span></dt><dd><dl><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id656200">Extracting information about the pattern</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id656311">Pattern matching with substrings</a></span></dt><dt><span class="sect2"><a href="interfacing-with-c-the-ffi.html#id656609">The real deal: compiling and matching regular expressions</a></span></dt></dl></dd></dl></div><p id="x_yG1"><a name="x_yG1"></a>
Programming languages do not exist in perfect isolation. They inhabit an
ecosystem of tools and libraries, built up over decades, and often written in
a range of programming languages. Good engineering practice suggests we reuse
that effort. The Haskell Foreign Function Interface (the "FFI") is the means
by which Haskell code can use, and be used by, code written in other
languages. In this chapter we'll look at how the FFI works, and how to
produce a Haskell binding to a C library, including how to use an FFI
preprocessor to automate much of the work. The challenge: take PCRE, the
standard Perl-compatible regular expression library, and make it usable from
Haskell in an efficient and functional way. Throughout, we'll seek to
abstract out manual effort required by the C implementation, delegating that
work to Haskell to make the interface more robust, yielding a clean, high
level binding.  We assume only some basic familiarity with regular
expressions.
</p><p id="x_zG1"><a name="x_zG1"></a>
Binding one language to another is a non-trivial task. The binding language
needs to understand the calling conventions, type system, data structures,
memory allocation mechanisms and linking strategy of the target language,
just to get things working. The task is to carefully align the semantics of
both languages, so that both languages can understand the data that
passes between them.
</p><p id="x_AH1"><a name="x_AH1"></a>
For Haskell, this technology stack is specified by <a class="ulink" href="http://www.cse.unsw.edu.au/~chak/haskell/ffi/" target="_top">the Foreign Function Interface addendum</a> to
the Haskell report. The FFI report describes how to correctly bind Haskell
and C together, and how to extend bindings to other languages. The
standard is designed to be portable, so that FFI bindings will work reliably
across Haskell implementations, operating systems and C compilers.
</p><p id="x_BH1"><a name="x_BH1"></a>
All implementations of Haskell support the FFI, and it is a key technology
when using Haskell in a new field. Instead of reimplementing the standard
libraries in a domain, we just bind to existing ones written in languages
other than Haskell.
</p><p id="x_CH1"><a name="x_CH1"></a>
The FFI adds a new dimension of flexibility to the language: if we need to
access raw hardware for some reason (say we're programming new hardware, or
implementing an operating system), the FFI lets us get access to that
hardware. It also gives us a performance escape hatch: if we can't get a code
hot spot fast enough, there's always the option of trying again in C.  So
let's look at what the FFI actually means for writing code. 
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id653815">Foreign language bindings: the basics</h2></div></div></div><p id="x_DH1"><a name="x_DH1"></a>
The most common operation we'll want to do, unsurprisingly, is to call a C
function from Haskell. So let's do that, by binding to some functions
from the standard C math library. We'll put the binding in a source file, and
then compile it into a Haskell binary that makes use of the C code.
</p><p id="x_EH1"><a name="x_EH1"></a>
To start with, we need to enable the foreign function interface extension, as
the FFI addendum support isn't enabled by default. We do this, as always, via
a <code class="code">LANGUAGE</code> pragma at the top of our source file:
</p><a name="SimpleFFI.hs:pragma"></a><pre id="SimpleFFI.hs:pragma" class="programlisting">-- file: ch17/SimpleFFI.hs
{-# LANGUAGE ForeignFunctionInterface #-}</pre><p id="x_FH1"><a name="x_FH1"></a>
The <code class="code">LANGUAGE</code> pragmas indicate which extensions to Haskell 98 a
module uses. We bring just the FFI extension in play this time. It is important
to track which extensions to the language you need. Fewer extensions generally
means more portable, more robust code. Indeed, it is common for Haskell
programs written more than a decade ago to compile perfectly well today,
thanks to standardization, despite changes to the language's syntax, type system and
core libraries.
</p><p id="x_GH1"><a name="x_GH1"></a>
The next step is to import the <code class="code">Foreign</code> modules, which provide
useful types (such as pointers, numerical types, arrays) and utility
functions (such as <code class="code">malloc</code> and <code class="code">alloca</code>), for writing
bindings to other languages:
</p><a name="SimpleFFI.hs:imports"></a><pre id="SimpleFFI.hs:imports" class="programlisting">-- file: ch17/SimpleFFI.hs
import Foreign
import Foreign.C.Types</pre><p id="x_HH1"><a name="x_HH1"></a>
For extensive work with foreign libraries, a good knowledge of the
<code class="code">Foreign</code> modules is essential. Other useful modules include
<code class="code">Foreign.C.String</code>, <code class="code">Foreign.Ptr</code> and
<code class="code">Foreign.Marshal.Array</code>.
</p><p id="x_IH1"><a name="x_IH1"></a>
Now we can get down to work calling C functions. To do this, we need
to know three things: the name of the C function, its type, and its
associated header file. Additionally, for code that isn't provided by the
standard C library, we'll need to know the C library's name, for linking
purposes.  The actual binding work is done with a <code class="code">foreign import</code>
declaration, like so:
</p><a name="SimpleFFI.hs:binding"></a><pre id="SimpleFFI.hs:binding" class="programlisting">-- file: ch17/SimpleFFI.hs
foreign import ccall "math.h sin"
     c_sin :: CDouble -&gt; CDouble</pre><p id="x_JH1"><a name="x_JH1"></a>
This defines a new Haskell function, <code class="code">c_sin</code>, whose concrete
implementation is in C, via the <code class="code">sin</code> function. When
<code class="code">c_sin</code> is called, a call to the actual <code class="code">sin</code> will be
made (using the standard C calling convention, indicated by
<code class="code">ccall</code> keyword). The Haskell runtime passes control to C, which
returns its results back to Haskell. The result is then wrapped up as a
Haskell value of type <code class="code">CDouble</code>.
</p><p id="x_KH1"><a name="x_KH1"></a>
A common idiom when writing FFI bindings is to expose the C function with the
prefix "c_", distinguishing it from more user-friendly, higher level
functions. The raw C function is specified by the <code class="code">math.h</code> header,
where it is declared to have the type:
</p><a name="math.c:type"></a><pre id="math.c:type" class="programlisting">double sin(double x);</pre><p id="x_LH1"><a name="x_LH1"></a>
When writing the binding, the programmer has to translate C type signatures
like this into their Haskell FFI equivalents, making sure that the data
representations match up. For example, <code class="code">double</code> in C corresponds
to <code class="code">CDouble</code> in Haskell. We need to be careful here, since if a
mistake is made the Haskell compiler will happily generate
incorrect code to call C! The poor Haskell compiler doesn't know anything
about what types the C function actually requires, so if instructed to, it
will call the C function with the wrong arguments.  At best this will lead to
C compiler warnings, and more likely, it will end with with a runtime crash. At
worst the error will silently go unnoticed until some critical failure
occurs. So make sure you use the correct FFI types, and don't be wary of
using QuickCheck to test your C code via the bindings.
<sup>[<a name="id654015" href="#ftn.id654015" class="footnote">36</a>]</sup>
</p><p id="x_NH1"><a name="x_NH1"></a> 
The most important primitive C types are represented in Haskell with the
somewhat intuitive names (for signed and unsigned types) <code class="code">CChar</code>, <code class="code">CUChar</code>, <code class="code">CInt</code>,
<code class="code">CUInt</code>, <code class="code">CLong</code>, <code class="code">CULong</code>,
<code class="code">CSize</code>, <code class="code">CFloat</code>, <code class="code">CDouble</code>. More are
defined in the FFI standard, and can be found in the Haskell base library
under <code class="code">Foreign.C.Types</code>.  It is also possible to define your own
Haskell-side representation types for C, as we'll see later.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654076">Be careful of side effects</h3></div></div></div><p id="x_OH1"><a name="x_OH1"></a>
One point to note is that we bound <code class="code">sin</code> as a pure function in Haskell, 
one with no side effects. That's fine in this case, since the <code class="code">sin</code>
function in C is referentially transparent. By binding pure C functions to
pure Haskell functions, the Haskell compiler is taught something about the C
code, namely that it has no side effects, making optimisations easier. Pure
code is also more flexible code for the Haskell programmer, as it yields naturally
persistent data structures, and threadsafe functions. However, while pure
Haskell code is always threadsafe, this is harder to guarantee of C. Even if
the documentation indicates the function is likely to expose no side effects,
there's little to ensure it is also threadsafe, unless explicitly documented
as "reentrant".  Pure, threadsafe C code, while rare, is a valuable
commodity. It is the easiest flavor of C to use from Haskell.
</p><p id="x_PH1"><a name="x_PH1"></a>
Of course, code with side effects is more common in imperative languages,
where the explicit sequencing of statements encourages the use of effects. It
is much more common in C for functions to return different values, given the
same arguments, due to changes in global or local state, or to have other
side effects. Typically this is signalled in C by the function returning only
a status value, or some void type, rather than a useful result value.  This
indicates that the real work of the function was in its side effects. For
such functions, we'll need to capture those side effects in the IO monad (by
changing the return type to <code class="code">IO CDouble</code>, for example). We also need to
be very careful with pure C functions that aren't also reentrant, as multiple
threads are extremely common in Haskell code, in comparison to C. We might
need to make non-reentrant code safe for use by moderating access to the
FFI binding with a transactional lock, or duplicating the underlying C state.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654123">A high level wrapper</h3></div></div></div><p id="x_QH1"><a name="x_QH1"></a>
With the foreign imports out of the way, the next step is to convert the C
types we pass to and receive from the foreign language call into native Haskell
types, wrapping the binding so it appears as a normal Haskell function:
</p><a name="SimpleFFI.hs:highlevel"></a><pre id="SimpleFFI.hs:highlevel" class="programlisting">-- file: ch17/SimpleFFI.hs
fastsin :: Double -&gt; Double
fastsin x = realToFrac (c_sin (realToFrac x))</pre><p id="x_RH1"><a name="x_RH1"></a>
The main thing to remember when writing convenient wrappers over
bindings like this is to convert input and output back to normal
Haskell types correctly. To convert between floating point values, we can use
<code class="code">realToFrac</code>, which lets us translate different floating point values
to each other (and these conversions, such as from <code class="code">CDouble</code> to
<code class="code">Double</code>, are usually free, as the underlying representations are
unchanged). For integer values <code class="code">fromIntegral</code> is available.
For other common C data types, such as arrays, we may need to unpack the data
to a more workable Haskell type (such as a list), or possibly leave the C
data opaque, and operate on it only indirectly (perhaps via a
<code class="code">ByteString</code>). The choice depends on how costly the
transformation is, and on what functions are available on the source
and destination types.
</p><p id="x_SH1"><a name="x_SH1"></a>
We can now proceed to use the bound function in a program. For
example, we can apply the C <code class="code">sin</code> function to a Haskell list of
tenths:
</p><a name="SimpleFFI.hs:use"></a><pre id="SimpleFFI.hs:use" class="programlisting">-- file: ch17/SimpleFFI.hs
main = mapM_ (print . fastsin) [0/10, 1/10 .. 10/10]</pre><p id="x_TH1"><a name="x_TH1"></a>
This simple program prints each result as it is computed.
Putting the complete binding in the file <code class="code">SimpleFFI.hs</code> we can run
it in <code class="code">GHCi</code>:
</p><pre id="id654218" class="screen">
$ ghci SimpleFFI.hs
*Main&gt; main
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964
</pre><p id="x_UH1"><a name="x_UH1"></a>
Alternatively, we can compile the code to an executable, dynamically linked
against the corresponding C library:
</p><pre id="id654236" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>ghc -O --make SimpleFFI.hs</code></strong>
[1 of 1] Compiling Main             ( SimpleFFI.hs, SimpleFFI.o )
Linking SimpleFFI ...
</pre><p id="x_VH1"><a name="x_VH1"></a>
and then run that:
</p><pre id="id654260" class="screen">
$ ./SimpleFFI 
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964
</pre><p id="x_WH1"><a name="x_WH1"></a>
We're well on our way now, with a full program, statically linked against
C, which interleaves C and Haskell code, and passes data across the language
boundary.  Simple bindings like the above are almost trivial, as the standard
<code class="code">Foreign</code> library provides convenient aliases for common types
like <code class="code">CDouble</code>. In the next section we'll look at a larger
engineering task: binding to the PCRE library, which brings up issues of
memory management and type safety.
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id654294">Regular expressions for Haskell: a binding for PCRE</h2></div></div></div><p id="x_XH1"><a name="x_XH1"></a>
As we've seen in previous sections, Haskell programs have something of a bias
towards lists as a foundational data structure.  List functions are a core
part of the base library, and convenient syntax for constructing and taking
apart list structures is wired into the language. Strings are, of course,
simply lists of characters (rather than, for example, flat arrays of characters).
This flexibility is all well and good, but it results in a tendency for the
standard library to favour polymorphic list operations at the expense of
string-specific operations.
</p><p id="x_YH1"><a name="x_YH1"></a>
Indeed, many common tasks can be solved via regular-expression-based
string processing, yet support for regular expressions isn't part of the
Haskell <code class="literal">Prelude</code>. So let's look at how we'd take an
off-the-shelf regular expression library, PCRE, and provide a natural,
convenient Haskell binding to it, giving us useful regular expressions for
Haskell.
</p><p id="x_ZH1"><a name="x_ZH1"></a>
PCRE itself is a ubiquitous C library implementing Perl-style regular expressions.
It is widely available, and preinstalled on many systems. If not, it can be
found at <a class="ulink" href="http://www.pcre.org/" target="_top">http://www.pcre.org/</a>. In the following
sections we'll assume the PCRE library and headers are available on the
machine.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654351">Simple tasks: using the C preprocessor</h3></div></div></div><p id="x_aH1"><a name="x_aH1"></a>
The simplest task when setting out to write a new FFI binding from Haskell to C
is to bind constants defined in C headers to equivalent Haskell
values. For example, PCRE provides a set of flags for modifying how the core
pattern matching system works (such as ignoring case, or allowing matching on
newlines).  These flags appear as numeric constants in the PCRE header files:
</p><a name="PCRE.h:constants"></a><pre id="PCRE.h:constants" class="programlisting">/* Options */

#define PCRE_CASELESS           0x00000001
#define PCRE_MULTILINE          0x00000002
#define PCRE_DOTALL             0x00000004
#define PCRE_EXTENDED           0x00000008</pre><p id="x_bH1"><a name="x_bH1"></a>
To export these values to Haskell we need to insert them into a Haskell
source file somehow. One obvious way to do this is by using the C
preprocessor to substitute definitions from C into the Haskell source, which we
then compile as a normal Haskell source file. Using the preprocessor we can
even declare simple constants, via textual substitutions on the Haskell
source file:
</p><a name="Enum1.hs:cpp"></a><pre id="Enum1.hs:cpp" class="programlisting">-- file: ch17/Enum1.hs
{-# LANGUAGE CPP #-}

#define N 16

main = print [ 1 .. N ]</pre><p id="x_cH1"><a name="x_cH1"></a>
The file is processed with the preprocessor in a similar manner to C source
(with CPP run for us by the Haskell compiler, when it spots the
<code class="code">LANGUAGE</code> pragma), resulting in program output:
</p><pre id="id654410" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>runhaskell Enum.hs</code></strong>
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
</pre><p id="x_dH1"><a name="x_dH1"></a>  
However, relying on CPP is a rather fragile approach. The C preprocessor
isn't aware it is processing a Haskell source file, and will happily include
text, or transform source, in such a way as to make our Haskell code invalid.
We need to be careful not to confuse CPP. If we were to include C headers we
risk substituting unwanted symbols, or inserting C type information and
prototypes into the Haskell source, resulting in a broken mess.
</p><p id="x_eH1"><a name="x_eH1"></a>
To solve these problems, the binding preprocessor <code class="code">hsc2hs</code> is
distributed with GHC. It provides a convenient syntax for including C binding
information in Haskell, as well as letting us safely operate with headers.
It is the tool of choice for the majority of Haskell FFI bindings.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654451">
Binding Haskell to C with hsc2hs
  </h3></div></div></div><p id="x_fH1"><a name="x_fH1"></a>
To use hsc2hs as an intelligent binding tool for Haskell, we need to create
an <code class="code">.hsc</code> file, <code class="code">Regex.hsc</code>, which will hold the Haskell source for our
binding, along with hsc2hs processing rules, C headers and C type
information. To start off, we need some pragmas and imports:
</p><a name="Regex-hsc.hs:headers"></a><pre id="Regex-hsc.hs:headers" class="programlisting">-- file: ch17/Regex-hsc.hs
{-# LANGUAGE CPP, ForeignFunctionInterface #-}

module Regex where

import Foreign
import Foreign.C.Types

#include &lt;pcre.h&gt;</pre><p id="x_gH1"><a name="x_gH1"></a>
The module begins with a typical preamble for an FFI binding: enable CPP,
enable the foreign function interface syntax, declare a module name, and then
import some things from the base library. The unusual item is the final line,
where we include the C header for PCRE. This wouldn't be valid in a
<code class="code">.hs</code> source file, but is fine in <code class="code">.hsc</code> code.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654503">
   Adding type safety to PCRE
  </h3></div></div></div><p id="x_hH1"><a name="x_hH1"></a>
Next we need a type to represent PCRE compile-time flags. In C, these are
integer flags to the <code class="code">compile</code> function, so we could just use
<code class="code">CInt</code> to represent them. All we know about the flags is that
they're C numeric constants, so <code class="code">CInt</code> is the appropriate
representation.
</p><p id="x_iH1"><a name="x_iH1"></a>
As a Haskell library writer though, this feels sloppy. The type of values
that can be used as regex flags contains fewer values than <code class="code">CInt</code>
allows for.  Nothing would prevent the end user passing illegal integer
values as arguments, or mixing up flags that should be passed only at regex
compile time, with runtime flags. It is also possible to do arbitrary math on
flags, or make other mistakes where integers and flags are confused. We
really need to more precisely specify that the type of flags is distinct from
its runtime representation as a numeric value. If we can do this, we can
statically prevent a class of bugs relating to misuse of flags.
</p><p id="x_jH1"><a name="x_jH1"></a>
Adding such a layer of type safety is relatively easy, and a great use case for
<code class="code">newtype</code>, the type introduction declaration.
What <code class="code">newtype</code> lets us do is create a type with an identical
runtime representation type to another type, but which is treated as a separate
type at compile time. We can represent flags as <code class="code">CInt</code>
values, but at compile time they'll be tagged distinctly for the
type checker. This makes it a type error to use invalid flag values (as we
specify only those valid flags, and prevent access to the data constructor),
or to pass flags to functions expecting integers. We get to use the Haskell type
system to introduce a layer of type safety to the C PCRE API.
</p><p id="x_kH1"><a name="x_kH1"></a>
To do this, we define a <code class="code">newtype</code> for PCRE compile time options,
whose representation is actually that of a <code class="code">CInt</code> value, like so:
</p><a name="Regex-hsc.hs:newtype"></a><pre id="Regex-hsc.hs:newtype" class="programlisting">-- file: ch17/Regex-hsc.hs
-- | A type for PCRE compile-time options. These are newtyped CInts,
-- which can be bitwise-or'd together, using '(Data.Bits..|.)'
--
newtype PCREOption = PCREOption { unPCREOption :: CInt }
    deriving (Eq,Show)</pre><p id="x_lH1"><a name="x_lH1"></a>
The type name is <code class="code">PCREOption</code>, and it has a single constructor,
also named <code class="code">PCREOption</code>, which lifts a <code class="code">CInt</code> value
into a new type by wrapping it in a constructor. We can also happily define
an accessor, <code class="code">unPCREOption</code>, using the Haskell record syntax, to the underlying
<code class="code">CInt</code>. That's a lot of convenience in one line. While we're here,
we can also derive some useful type class operations for flags (equality
and printing). We also need to remember export the data constructor
abstractly from the source module, ensuring users can't construct their own
<code class="code">PCREOption</code> values.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654629">
Binding to constants
  </h3></div></div></div><p id="x_mH1"><a name="x_mH1"></a>
Now we've pulled in the required modules, turned on the language features we
need, and defined a type to represent PCRE options, we need to actually
define some Haskell values corresponding to those PCRE constants.
</p><p id="x_nH1"><a name="x_nH1"></a>
We can do this in two ways with hsc2hs. The first way is to use the
<code class="code">#const</code> keyword hsc2hs provides. This lets us name constants to
be provided by the C preprocessor. We can bind to the constants manually, by
listing the CPP symbols for them using the <code class="code">#const</code> keyword:
</p><a name="Regex-hsc-const.hs:constoptions"></a><pre id="Regex-hsc-const.hs:constoptions" class="programlisting">-- file: ch17/Regex-hsc-const.hs
caseless       :: PCREOption
caseless       = PCREOption #const PCRE_CASELESS

dollar_endonly :: PCREOption
dollar_endonly = PCREOption #const PCRE_DOLLAR_ENDONLY

dotall         :: PCREOption
dotall         = PCREOption #const PCRE_DOTALL</pre><p id="x_oH1"><a name="x_oH1"></a>
This introduces three new constants on the Haskell side,
<code class="code">caseless</code>, <code class="code">dollar_endonly</code> and <code class="code">dotall</code>,
corresponding to the similarly named C definitions. We immediately wrap the
constants in a newtype constructor, so they're exposed to the programmer as
abstract <code class="code">PCREOption</code> types only.
</p><p id="x_pH1"><a name="x_pH1"></a>
This is the first step, creating a <code class="code">.hsc</code> file. We now need to
actually create a Haskell source file, with the C preprocessing done. Time
to run <code class="code">hsc2hs</code> over the <code class="code">.hsc</code> file:
</p><pre id="id654716" class="screen">
$ hsc2hs Regex.hsc
</pre><p id="x_qH1"><a name="x_qH1"></a>
This creates a new output file, <code class="code">Regex.hs</code>, where the CPP
variables have been expanded, yielding valid Haskell code:
</p><a name="Regex-hsc-const-generated.hs:generatedconsts"></a><pre id="Regex-hsc-const-generated.hs:generatedconsts" class="programlisting">-- file: ch17/Regex-hsc-const-generated.hs
caseless       :: PCREOption
caseless       = PCREOption 1
{-# LINE 21 "Regex.hsc" #-}

dollar_endonly :: PCREOption
dollar_endonly = PCREOption 32
{-# LINE 24 "Regex.hsc" #-}

dotall         :: PCREOption
dotall         = PCREOption 4
{-# LINE 27 "Regex.hsc" #-}</pre><p id="x_rH1"><a name="x_rH1"></a>
Notice also how the original line in the <code class="code">.hsc</code> is listed next
to each expanded definition via the <code class="code">LINE</code> pragma. The compiler
uses this information to report errors in terms of their source, in the
original file, rather than the generated one.  We can load this generated
<code class="code">.hs</code> file into the interpreter, and play with the results:
</p><pre id="id654766" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>ghci Regex.hs</code></strong>
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>caseless</code></strong>
PCREOption {unPCREOption = 1}
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>unPCREOption caseless</code></strong>
1
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>unPCREOption caseless + unPCREOption caseless</code></strong>
2
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>caseless + caseless</code></strong>
interactive&gt;:1:0:
    No instance for (Num PCREOption)
</pre><p id="x_sH1"><a name="x_sH1"></a>
So things are working as expected. The values are opaque, we get type errors
if we try to break the abstraction, and we can unwrap them and operate on
them if needed. The <code class="code">unPCREOption</code> accessor is used to unwrap the
boxes.  That's a good start, but let's see how we can simplify this task
further.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id654840">
Automating the binding
  </h3></div></div></div><p id="x_tH1"><a name="x_tH1"></a>
Clearly, manually listing all the C defines, and wrapping them is tedious,
and error prone. The work of wrapping all the literals in
<code class="code">newtype</code> constructors is also annoying. This kind of binding is
such a common task that <code class="code">hsc2hs</code> provides convenient syntax to
automate it: the <code class="code">#enum</code> construct.
</p><p id="x_uH1"><a name="x_uH1"></a>
We can replace our list of top level bindings with the equivalent:
</p><a name="Regex-hsc.hs:constants"></a><pre id="Regex-hsc.hs:constants" class="programlisting">-- file: ch17/Regex-hsc.hs
-- PCRE compile options
#{enum PCREOption, PCREOption
  , caseless             = PCRE_CASELESS
  , dollar_endonly       = PCRE_DOLLAR_ENDONLY
  , dotall               = PCRE_DOTALL
  }</pre><p id="x_vH1"><a name="x_vH1"></a>
This is much more concise! The <code class="code">#enum</code> construct gives us three
fields to work with. The first is the name of the type we'd like the C
defines to be treated as. This lets us pick something other than just
<code class="code">CInt</code> for the binding. We chose <code class="code">PCREOption</code>'s to
construct.
</p><p id="x_wH1"><a name="x_wH1"></a>
The second field is an optional constructor to place in front of the symbols.
This is specifically for the case we want to construct <code class="code">newtype</code>
values, and where much of the grunt work is saved. The final part of the
<code class="code">#enum</code> syntax is self explanatory: it just defines Haskell names
for constants to be filled in via CPP.
</p><p id="x_xH1"><a name="x_xH1"></a>
Running this code through hsc2hs, as before, generates a Haskell file with
the following binding code produced (with <code class="code">LINE</code> pragmas removed
for brevity):
</p><a name="Regex.hs:result"></a><pre id="Regex.hs:result" class="programlisting">-- file: ch17/Regex.hs
caseless              :: PCREOption
caseless              = PCREOption 1
dollar_endonly        :: PCREOption
dollar_endonly        = PCREOption 32
dotall                :: PCREOption
dotall                = PCREOption 4</pre><p id="x_yH1"><a name="x_yH1"></a>
Perfect. Now we can do something in Haskell with these values. Our aim here
is to treat flags as abstract types, not as bit fields in integers in C.
Passing multiple flags in C would be done by bitwise or-ing multiple flags 
together. For an abstract type though, that would expose too much
information. Preserving the abstraction, and giving it a Haskell flavor,
we'd prefer users passed in flags in a list that the library itself combined.
This is achievable with a simple fold: </p><a name="Regex.hs:bitwise"></a><pre id="Regex.hs:bitwise" class="programlisting">-- file: ch17/Regex.hs
-- | Combine a list of options into a single option, using bitwise (.|.)
combineOptions :: [PCREOption] -&gt; PCREOption
combineOptions = PCREOption . foldr ((.|.) . unPCREOption) 0</pre><p id="x_zH1"><a name="x_zH1"></a>
This simple loop starts with an initial value of 0, unpacks each flag, and
uses bitwise-or, <code class="code">(.|.)</code> on the underlying <code class="code">CInt</code>, to
combine each value with the loop accumulator. The final accumulated state is
then wrapped up in the
<code class="code">PCREOption</code> constructor.
</p><p id="x_AI1"><a name="x_AI1"></a>
Let's turn now to actually compiling some regular expressions.
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id654997">Passing string data between Haskell and C</h2></div></div></div><p id="x_BI1"><a name="x_BI1"></a>
The next task is to write a binding to the PCRE regular expression
<code class="code">compile</code> function. Let's look at its type, straight from the
<code class="code">pcre.h</code> header file:
</p><a name="PCRE-compile.h:pcre_compile"></a><pre id="PCRE-compile.h:pcre_compile" class="programlisting">pcre *pcre_compile(const char *pattern,
                   int options,
                   const char **errptr,
                   int *erroffset,
                   const unsigned char *tableptr);</pre><p id="x_CI1"><a name="x_CI1"></a>
This function compiles a regular expression pattern into some internal
format, taking the pattern as an argument, along with some flags, and some
variables for returning status information.
</p><p id="x_DI1"><a name="x_DI1"></a>
We need to work out what Haskell types to represent each argument with. Most
of these types are covered by equivalents defined for us by the FFI standard,
and available in <code class="code">Foreign.C.Types</code>. The first argument, the
regular expression itself, is passed as a null-terminated char pointer to C,
equivalent to the Haskell <code class="code">CString</code> type. PCRE compile time
options we've already chosen to represent as the abstract
<code class="code">PCREOption</code> newtype, whose runtime representation is a
<code class="code">CInt</code>. As the representations are guaranteed to be identical, we
can pass the <code class="code">newtype</code> safely. The other arguments are a little
more complicated and require some work to construct and take apart.
</p><p id="x_EI1"><a name="x_EI1"></a>
The third argument, a pointer to a C string, will be used as a reference  to
any error message generated when compiling the expression. The value of the
pointer will be modified by the C function to point to a custom error string.
This we can represent with a <code class="code">Ptr CString</code> type. Pointers in
Haskell are heap allocated containers for raw addresses, and can be created
and operated on with a number of allocation primitives in the FFI library.
For example, we can represent a pointer to a C <code class="code">int</code> as <code class="code">Ptr
CInt</code>, and a pointer to an unsigned char as a <code class="code">Ptr
Word8</code>.
</p><div class="note"><table border="0" summary="Note: A note about pointers"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/support/figs/note.png"></td><th align="left">A note about pointers</th></tr><tr><td align="left" valign="top"><p id="x_FI1"><a name="x_FI1"></a>
Once we have a Haskell <code class="code">Ptr</code> value handy, we can do various
pointer-like things with it. We can compare it for equality with the null
pointer, represented with the special <code class="code">nullPtr</code> constant. We can
cast a pointer from one type to a pointer to another, or we can advance a
pointer by an offset in bytes with <code class="code">plusPtr</code>. We can even modify
the value pointed to, using <code class="code">poke</code>, and of course dereference a
pointer yielding that which it points to, with <code class="code">peek</code>.
In the majority of circumstances, a Haskell programmer doesn't need to
operate on pointers directly, but when they are needed these tools come in
handy.
</p></td></tr></table></div><p id="x_GI1"><a name="x_GI1"></a>
The question then is how to represent the abstract <code class="code">pcre</code> pointer
returned when we compile the regular expression. We need to find a Haskell
type that is as abstract as the C type. Since the C type is treated
abstractly, we can assign any heap-allocated Haskell type to the data, as
long as it has few or no operations on it.  This is a common trick for
arbitrarily typed foreign data.  The idiomatic simple type to use to
represent unknown foreign data is a pointer to the <code class="code">()</code> type.
We can use a type synonym to remember the binding:
</p><a name="PCRE-compile.hs:unit"></a><pre id="PCRE-compile.hs:unit" class="programlisting">-- file: ch17/PCRE-compile.hs
type PCRE = ()</pre><p id="x_HI1"><a name="x_HI1"></a>
That is, the foreign data is some unknown, opaque object, and we'll just
treat it as a pointer to <code class="code">()</code>, knowing full well that we'll never
actually dereference that pointer. This gives us the following foreign import
binding for <code class="code">pcre_compile</code>, which must be in <code class="code">IO</code>, as
the pointer returned will vary on each call, even if the returned object is
functionally equivalent:
</p><a name="PCRE-compile.hs:pcre_compile"></a><pre id="PCRE-compile.hs:pcre_compile" class="programlisting">-- file: ch17/PCRE-compile.hs
foreign import ccall unsafe "pcre.h pcre_compile"
    c_pcre_compile  :: CString
                    -&gt; PCREOption
                    -&gt; Ptr CString
                    -&gt; Ptr CInt
                    -&gt; Ptr Word8
                    -&gt; IO (Ptr PCRE)</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655194">
    Typed pointers
  </h3></div></div></div><div class="note"><table border="0" summary="Note: A note about safety"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="/support/figs/note.png"></td><th align="left">A note about safety</th></tr><tr><td align="left" valign="top"><p id="x_dO1"><a name="x_dO1"></a>
When making a foreign import declaration, we can optionally specify a
"safety" level to use when making the call, using either the
<code class="code">safe</code> or <code class="code">unsafe</code> keyword. A safe call is less
efficient, but guarantees that the Haskell system can be safely called into
from C. An "unsafe" call has far less overhead, but the C code that is called
must not call back into Haskell.  By default foreign imports are "safe", but
in practice it is rare for C code to call back into Haskell, so for
efficiency we mostly use "unsafe" calls.
</p></td></tr></table></div><p id="x_II1"><a name="x_II1"></a>

We can increase safety in the binding futher by using a "typed" pointer,
instead of using the <code class="code">()</code> type. That is, a unique type, distinct
from the unit type, that has no meaningful runtime representation. A type for
which no data can be constructed, making dereferencing it a type error. One
good way to build such provably uninspectable data types is with a nullary
data type:
</p><a name="PCRE-nullary.hs:nullary"></a><pre id="PCRE-nullary.hs:nullary" class="programlisting">-- file: ch17/PCRE-nullary.hs
data PCRE</pre><p id="x_JI1"><a name="x_JI1"></a>
This requires the <code class="code">EmptyDataDecls</code> language extension. This type
clearly contains no values! We can only ever construct pointers to such
values, as there are no concrete values (other than bottom) that have this
type.
</p><p id="x_KI1"><a name="x_KI1"></a>
We can also achieve the same thing, without requiring a language extension, 
using a recursive <code class="code">newtype</code>:
</p><a name="PCRE-recursive.hs:nullary"></a><pre id="PCRE-recursive.hs:nullary" class="programlisting">-- file: ch17/PCRE-recursive.hs
newtype PCRE = PCRE (Ptr PCRE)</pre><p id="x_LI1"><a name="x_LI1"></a>
Again, we can't really do anything with a value of this type, as it has no
runtime representation. Using typed pointers in these ways is just
another way to add safety to a Haskell layer over what C provides. What would require
discipline on the part of the C programmer (remembering never to dereference a
PCRE pointer) can be enforced statically in the type system of the Haskell
binding. If this code compiles, the type checker has given us a proof that
the PCRE objects returned by C are never dereferenced on the Haskell side.
</p><p id="x_MI1"><a name="x_MI1"></a>
We have the foreign import declaration sorted out now, the next step is to
marshal data into the right form, so that we can finally call the C code.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655309">
    Memory management: let the garbage collector do the work
  </h3></div></div></div><p id="x_NI1"><a name="x_NI1"></a>
One question that isn't resolved yet is how to manage the memory associated
with the abstract <code class="code">PCRE</code> structure returned by the C library. The
caller didn't have to allocate it: the library took care of that by
allocating memory on the C side. At some point though we'll need to
deallocate it. This, again, is an opportunity to abstract the tedium of using
the C library by hiding the complexity inside the Haskell binding.  </p><p id="x_OI1"><a name="x_OI1"></a>
We'll use the Haskell garbage collector to automatically deallocate the C
structure once it is no longer in use. To do this, we'll make use of Haskell
garbage collector finalizers, and the <code class="code">ForeignPtr</code> type.
</p><p id="x_PI1"><a name="x_PI1"></a>
We don't want users to have to manually deallocate the <code class="code">Ptr PCRE</code>
value returned by the foreign call. The PCRE library specifically states that
structures are allocated on the C side with <code class="code">malloc</code>, and need to be freed
when no longer in use, or we risk leaking memory. The Haskell garbage
collector already goes to great lengths to automate the task of managing
memory for Haskell values. Cleverly, we can also assign our hardworking
garbage collector the task of looking after C's memory for us. The trick is to
associate a piece of Haskell data with the foreign allocator data, and give
the Haskell garbage collector an arbitrary function that is to deallocate the C resource once
it notices that the Haskell data is done with.
</p><p id="x_QI1"><a name="x_QI1"></a>
We have two tools at our disposal here, the opaque <code class="code">ForeignPtr</code>
data type, and the <code class="code">newForeignPtr</code> function, which has type:
</p><a name="ForeignPtr.hs:newForeignPtr"></a><pre id="ForeignPtr.hs:newForeignPtr" class="programlisting">-- file: ch17/ForeignPtr.hs
newForeignPtr :: FinalizerPtr a -&gt; Ptr a -&gt; IO (ForeignPtr a)</pre><p id="x_RI1"><a name="x_RI1"></a>
The function takes two arguments, a finalizer to run when the data goes out
of scope, and a pointer to the associated C data. It returns a new managed
pointer which will have its finalizer run once the garbage collector decides
the data is no longer in use. What a lovely abstraction!
</p><p id="x_SI1"><a name="x_SI1"></a>
These finalizable pointers are appropriate whenever a C library requires the
user to explicitly deallocate, or otherwise clean up a resource, when it is
no longer in use. It is a simple piece of equipment that goes a long way
towards making the C library binding more natural, more functional, in
flavor.
</p><p id="x_TI1"><a name="x_TI1"></a>
So with this in mind, we can hide the manually managed <code class="code">Ptr PCRE</code>
type inside an automatically managed data structure, yielding us the
data type used to represent regular expressions that users will see:
</p><a name="PCRE-compile.hs:data"></a><pre id="PCRE-compile.hs:data" class="programlisting">-- file: ch17/PCRE-compile.hs
data Regex = Regex !(ForeignPtr PCRE)
                   !ByteString
        deriving (Eq, Ord, Show)</pre><p id="x_UI1"><a name="x_UI1"></a>
This new <code class="code">Regex</code> data types consists of two parts. The first is
an abstract <code class="code">ForeignPtr</code>, that we'll use to manage the underlying
<code class="code">PCRE</code> data allocated in C. The second component is a strict
<code class="code">ByteString</code>, which is the string representation of the regular
expression that we compiled. By keeping it the user-level representation of
the regular expression handy inside the <code class="code">Regex</code> type, it'll be
easier to print friendly error messages, and show the <code class="code">Regex</code>
itself in a meaningful way.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655462">
    A high level interface: marshalling data
  </h3></div></div></div><p id="x_VI1"><a name="x_VI1"></a>
The challenge when writing FFI bindings, once the Haskell types have been
decided upon, is to convert regular data types a Haskell programmer will be
familiar with into low level pointers to arrays and other C types. What would
an ideal Haskell interface to regular expression compilation look like?
We have some design intuitions to guide us.
</p><p id="x_WI1"><a name="x_WI1"></a>
For starters, the act of compilation should be a referentially transparent
operation: passing the same regex string will yield functionally the same
compiled pattern each time, although the C library will give us observably
different pointers to functionally identical expressions. If we can hide
these memory management details, we should be able to represent the binding
as a pure function. The ability to represent a C function in Haskell as a
pure operation is a key step towards flexibility, and an indicator the
interface will be easy to use (as it won't require complicated state to be
initialized before it can be used).
</p><p id="x_XI1"><a name="x_XI1"></a>
Despite being pure, the function can still fail. If the regular expression
input provided by the user is ill-formed an error string is returned. A good
data type to represent optional failure with an error value, is
<code class="code">Either</code>. That is, either we return a valid compiled regular
expression, or we'll return an error string. Encoding the results of a C
function in a familiar, foundational Haskell type like this is another useful
step to make the binding more idiomatic.
</p><p id="x_YI1"><a name="x_YI1"></a>
For the user-supplied parameters, we've already decided to pass compilation
flags in as a list. We can choose to pass the input regular expression either
as an efficient <code class="code">ByteString</code>, or as a regular <code class="code">String</code>.
An appropriate type signature, then, for referentially transparent
compilation success with a value or failure with an error string, would be:
</p><a name="PCRE-compile.hs:compiletype"></a><pre id="PCRE-compile.hs:compiletype" class="programlisting">-- file: ch17/PCRE-compile.hs
compile :: ByteString -&gt; [PCREOption] -&gt; Either String Regex</pre><p id="x_ZI1"><a name="x_ZI1"></a>
The input is a <code class="code">ByteString</code>, available from the
<code class="code">Data.ByteString.Char8</code> module (and we'll import this
<code class="code">qualified</code> to avoid name clashes), containing the regular
expression, and a list of flags (or the empty list if there are no flags to
pass). The result is either an error string, or a new, compiled regular
expression.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655555">Mashalling ByteStrings</h3></div></div></div><p id="x_aI1"><a name="x_aI1"></a>
Given this type, we can sketch out the <code class="code">compile</code> function: the
high level interface to the raw C binding. At its heart, it will call
<code class="code">c_pcre_compile</code>. Before it does that, it has to marshal the
input <code class="code">ByteString</code> into a <code class="code">CString</code>. This is done with
the <code class="code">ByteString</code> library's <code class="code">useAsCString</code> function,
which copies the input <code class="code">ByteString</code> into a null-terminated C array
(there is also an unsafe, zero copy variant, that assumes the
<code class="code">ByteString</code> is already null terminated):
</p><a name="ForeignPtr.hs:useAsCString"></a><pre id="ForeignPtr.hs:useAsCString" class="programlisting">-- file: ch17/ForeignPtr.hs
useAsCString :: ByteString -&gt; (CString -&gt; IO a) -&gt; IO a</pre><p id="x_bI1"><a name="x_bI1"></a>
This function takes a <code class="code">ByteString</code> as input. The second
argument is a user-defined function that will run with the resulting
<code class="code">CString</code>. We see here another useful idiom:
data marshalling functions that are naturally scoped via closures. Our
<code class="code">useAsCString</code> function will convert the input data to a C string,
which we can then pass to C as a pointer. Our burden then is to supply it
with a chunk of code to call C.
</p><p id="x_cI1"><a name="x_cI1"></a>
Code in this style is often written in a dangling "do-block" notation. The
following pseudocode illustrates this structure:
</p><a name="DoBlock.hs:doblock"></a><pre id="DoBlock.hs:doblock" class="programlisting">-- file: ch17/DoBlock.hs
useAsCString str $ \cstr -&gt; do
   ... operate on the C string
   ... return a result</pre><p id="x_dI1"><a name="x_dI1"></a>
The second argument here is an anonymous function, a lambda, with a monadic
"do" block for a body. It is common to use the simple <code class="code">($)</code>
application operator to avoid the need for parentheses when delimiting the
code block argument. This is a useful idiom to remember when dealing with code block
parameters like this.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655666">Allocating local C data: the Storable class</h3></div></div></div><p id="x_eI1"><a name="x_eI1"></a> 
We can happily marshal <code class="code">ByteString</code> data to C compatible types,
but the <code class="code">pcre_compile</code> function also needs some pointers and
arrays in which to place its other return values. These should only exist
briefly, so we don't need complicated allocation strategies. Such
short-lifetime C data can be created with the <code class="code">alloca</code> function:
</p><a name="ForeignPtr.hs:alloc"></a><pre id="ForeignPtr.hs:alloc" class="programlisting">-- file: ch17/ForeignPtr.hs
alloca :: Storable a =&gt; (Ptr a -&gt; IO b) -&gt; IO b</pre><p id="x_fI1"><a name="x_fI1"></a>
This function takes a code block accepting a pointer to some C type as an
argument and arranges to call that function with the unitialised data of the
right shape, allocated freshly. The allocation mechanism mirrors local stack
variables in other languages. The allocated memory is released once the
argument function exits. In this way we get lexically scoped 
allocation of low level data types, that are guaranteed to be released once
the scope is exited. We can use it to allocate any data types that has an
instance of the <code class="code">Storable</code> type class. An implication of
overloading the allocation operator like this is that the data type
allocated can be inferred from type information, based on
use! Haskell will know what to allocate based on the functions we use on that
data.
</p><p id="x_gI1"><a name="x_gI1"></a>
To allocate a pointer to a <code class="code">CString</code>, for example, which will be
updated to point to a particular <code class="code">CString</code> by the called
function, we would call <code class="code">alloca</code>, in pseudocode as:
</p><a name="DoBlock.hs:alloc"></a><pre id="DoBlock.hs:alloc" class="programlisting">-- file: ch17/DoBlock.hs
alloca $ \stringptr -&gt; do
   ... call some Ptr CString function
   peek stringptr</pre><p id="x_hI1"><a name="x_hI1"></a>
This locally allocates a <code class="code">Ptr CString</code> and applies
the code block to that pointer, which then calls a C function to modify the
pointer contents. Finally, we dereference the pointer with the
<code class="code">Storable</code> class <code class="code">peek</code> function, yielding a
<code class="code">CString</code>.
</p><p id="x_iI1"><a name="x_iI1"></a>
We can now put it all together, to complete our high level PCRE compilation
wrapper.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id655783">Putting it all together</h3></div></div></div><p id="x_jI1"><a name="x_jI1"></a>
We've decided what Haskell type to represent the C function with, what the
result data will be represented by, and how its memory will be managed. We've
chosen a representation for flags to the <code class="code">pcre_compile</code> function,
and worked out how to get C strings to and from code inspecting it. So let's
write the complete function for compiling PCRE regular expressions from
Haskell:
</p><a name="PCRE-compile.hs:compileReal"></a><pre id="PCRE-compile.hs:compileReal" class="programlisting">-- file: ch17/PCRE-compile.hs
compile :: ByteString -&gt; [PCREOption] -&gt; Either String Regex
compile str flags = unsafePerformIO $
  useAsCString str $ \pattern -&gt; do
    alloca $ \errptr       -&gt; do
    alloca $ \erroffset    -&gt; do
        pcre_ptr &lt;- c_pcre_compile pattern (combineOptions flags) errptr erroffset nullPtr
        if pcre_ptr == nullPtr
            then do
                err &lt;- peekCString =&lt;&lt; peek errptr
                return (Left err)
            else do
                reg &lt;- newForeignPtr finalizerFree pcre_ptr -- release with free()
                return (Right (Regex reg str))</pre><p id="x_kI1"><a name="x_kI1"></a>
That's it! Let's carefully walk through the details here, since it is rather
dense. The first thing that stands out is the use of
<code class="code">unsafePerformIO</code>, a rather infamous function, with a very unusual
type, imported from the ominous <code class="code">System.IO.Unsafe</code>:
</p><a name="ForeignPtr.hs:unsafePerformIO"></a><pre id="ForeignPtr.hs:unsafePerformIO" class="programlisting">-- file: ch17/ForeignPtr.hs
unsafePerformIO :: IO a -&gt; a</pre><p id="x_lI1"><a name="x_lI1"></a>
This function does something odd: it takes an IO value and converts it to a
pure one! After warning about the danger of effects for so long, here we have
the very enabler of dangerous effects in one line. Used unwisely, this
function lets us sidestep all safety guarantees the Haskell type system
provides, inserting arbitrary side effects into a Haskell program, anywhere.
The dangers in doing this are significant: we can break optimizations, modify
arbitrary locations in memory, remove files on the user's machine, or launch
nuclear missiles from our Fibonacci sequences.  So why does this function
exist at all?
</p><p id="x_mI1"><a name="x_mI1"></a>
It exists precisely to enable Haskell to bind to C code that we know to
be referentially transparent, but can't prove the case to the Haskell type
system.  It lets us say to the compiler, "I know what I'm doing - this code
really is pure". For regular expression compilation, we know this to be the
case: given the same pattern, we should get the same regular expression
matcher every time. However, proving that to the compiler is beyond the
Haskell type system, so we're forced to assert that
this code is pure. Using <code class="code">unsafePerformIO</code> allows us to do just
that.
</p><p id="x_eO1"><a name="x_eO1"></a>
However, if we know the C code is pure, why don't we just declare it as such,
by giving it a pure type in the import declaration? For the reason that we
have to allocate local memory for the C function to work with, which must be
done in the IO monad, as it is a local side effect. Those effects won't
escape the code surrounding the foreign call, though, so when wrapped, we use
<code class="code">unsafePerformIO</code> to reintroduce purity.
</p><p id="x_nI1"><a name="x_nI1"></a>
The argument to <code class="code">unsafePerformIO</code> is the actual body of our
compilation function, which consists of four parts: marshalling Haskell data
to C form; calling into the C library; checking the return values; and
finally, constructing a Haskell value from the results.
</p><p id="x_oI1"><a name="x_oI1"></a>
We marshal with <code class="code">useAsCString</code> and <code class="code">alloca</code>, setting
up the data we need to pass to C, and use <code class="code">combineOptions</code>,
developed previously, to collapse the list of flags into a single
<code class="code">CInt</code>. Once that's all in place, we can finally call
<code class="code">c_pcre_compile</code> with the pattern, flags, and pointers for the
results. We use <code class="code">nullPtr</code> for the character encoding table, which
is unused in this case.
</p><p id="x_pI1"><a name="x_pI1"></a>
The result returned from the C call is a pointer to the abstract
<code class="code">PCRE</code> structure. We then test this against the
<code class="code">nullPtr</code>. If there was a problem with the regular expression, 
we have to dereference the error pointer, yielding a <code class="code">CString</code>. We
then unpack that to a normal Haskell list with the library function,
<code class="code">peekCString</code>. The final result of the error path is a value of
<code class="code">Left err</code>, indicating failure to the caller.
</p><p id="x_qI1"><a name="x_qI1"></a>
If the call succeeded, however, we allocate a new storage-managed pointer,
with the C function using a <code class="code">ForeignPtr</code>. The special value
<code class="code">finalizerFree</code> is bound as the finalizer for this data, which
uses the standard C <code class="code">free</code> to deallocate the
data. This is then wrapped as an opaque
<code class="code">Regex</code> value. The successful result is tagged as such with
<code class="code">Right</code>, and returned to the user. And now we're done!
</p><p id="x_rI1"><a name="x_rI1"></a>
We need to process our source file with hsc2hs, and then load the function in GHCi.
However, doing this results in an error on the first attempt:
</p><pre id="id656005" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>hsc2hs Regex.hsc</code></strong>
<code class="prompt">$ </code><strong class="userinput"><code>ghci Regex.hs</code></strong>

During interactive linking, GHCi couldn't find the following symbol:
  pcre_compile
This may be due to you not asking GHCi to load extra object files,
archives or DLLs needed by your current session.  Restart GHCi, specifying
the missing library using the -L/path/to/object/dir and -lmissinglibname
flags, or simply by naming the relevant files on the GHCi command line.
</pre><p id="x_sI1"><a name="x_sI1"></a>
A little scary. However, this is just because we didn't link the
C library we wanted to call to the Haskell code.  Assuming the PCRE library has
been installed on the system in the default library location, we can let
GHCi know about it by adding <code class="code">-lpcre</code> to the GHCi command line.
Now we can try out the code on some regular expressions, looking at the success and
error cases:
</p><pre id="id656047" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>ghci Regex.hs -lpcre</code></strong>
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>:m + Data.ByteString.Char8</code></strong>
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>compile (pack "a.*b") []</code></strong>
Right (Regex 0x00000000028882a0 "a.*b")
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>compile (pack "a.*b[xy]+(foo?)") []</code></strong>
Right (Regex 0x0000000002888860 "a.*b[xy]+(foo?)")
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>compile (pack "*") []</code></strong>
Left "nothing to repeat"
</pre><p id="x_tI1"><a name="x_tI1"></a>
The regular expressions are packed into byte strings and marshalled to C,
where they are compiled by the PCRE library. The result is then handed back
to Haskell, where we display the structure using the default
<code class="code">Show</code> instance.  Our next step is to pattern match some strings
with these compiled regular
expressions.
</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id656122">Matching on strings</h2></div></div></div><p id="x_uI1"><a name="x_uI1"></a>
The second part of a good regular expression library is the matching
function. Given a compiled regular expression, this function does
the matching of the compiled regex against some input, indicating whether it
matched, and if so, what parts of the string matched. In PCRE this function
is <code class="code">pcre_exec</code>, which has type:
</p><a name="PCRE-compile.h:pcre_exec"></a><pre id="PCRE-compile.h:pcre_exec" class="programlisting">int pcre_exec(const pcre *code,
              const pcre_extra *extra,
              const char *subject,
              int length,
              int startoffset,
              int options,
              int *ovector,
              int ovecsize);</pre><p id="x_vI1"><a name="x_vI1"></a>
The most important arguments are the input <code class="code">pcre</code> pointer
structure, which we obtained from <code class="code">pcre_compile</code>, and the subject
string. The other flags let us provide book keeping structures, and space for
return values. We can directly translate this type to the Haskell import
declaration:
</p><a name="RegexExec.hs:pcreexec"></a><pre id="RegexExec.hs:pcreexec" class="programlisting">-- file: ch17/RegexExec.hs
foreign import ccall "pcre.h pcre_exec"
    c_pcre_exec     :: Ptr PCRE
                    -&gt; Ptr PCREExtra
                    -&gt; Ptr Word8
                    -&gt; CInt
                    -&gt; CInt
                    -&gt; PCREExecOption
                    -&gt; Ptr CInt
                    -&gt; CInt
                    -&gt; IO CInt</pre><p id="x_wI1"><a name="x_wI1"></a>
We use the same method as before to create typed pointers for
the <code class="code">PCREExtra</code> structure, and a <code class="code">newtype</code> to
represent flags passed at regex execution time. This lets us ensure users
don't pass compile time flags incorrectly at regex runtime.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id656200">Extracting information about the pattern</h3></div></div></div><p id="x_xI1"><a name="x_xI1"></a>
The main complication involved in calling <code class="code">pcre_exec</code> is the
array of <code class="code">int</code> pointers used to hold the offsets of matching
substrings found by the pattern matcher. These offsets are held in an
offset vector, whose required size is determined by analysing the input
regular expression to determine the number of captured patterns it contains.
PCRE provides a function, <code class="code">pcre_fullinfo</code>, for determining
much information about the regular expression, including the number of patterns.
We'll need to call this, and now, we can directly write down the Haskell
type for the binding to <code class="code">pcre_fullinfo</code> as:
</p><a name="RegexExec.hs:pcrefullinfo"></a><pre id="RegexExec.hs:pcrefullinfo" class="programlisting">-- file: ch17/RegexExec.hs
foreign import ccall "pcre.h pcre_fullinfo"
    c_pcre_fullinfo :: Ptr PCRE
                    -&gt; Ptr PCREExtra
                    -&gt; PCREInfo
                    -&gt; Ptr a
                    -&gt; IO CInt</pre><p id="x_yI1"><a name="x_yI1"></a>
The most important arguments to this function are the compiled regular
expression, and the <code class="code">PCREInfo</code> flag, indicating which information
we're interested in. In this case, we care about the captured pattern count.
The flags are encoded in numeric constants, and we need to use specifically
the <code class="code">PCRE_INFO_CAPTURECOUNT</code> value. There is a range of other
constants which determine the result type of the function, which we can bind to
using the <code class="code">#enum</code> construct as before. The final argument is a
pointer to a location to store the information about the pattern (whose size
depends on the flag argument passed in!).
</p><p id="x_zI1"><a name="x_zI1"></a>
Calling <code class="code">pcre_fullinfo</code> to determine the captured pattern count
is pretty easy:
</p><a name="RegexExec.hs:captured"></a><pre id="RegexExec.hs:captured" class="programlisting">-- file: ch17/RegexExec.hs
capturedCount :: Ptr PCRE -&gt; IO Int
capturedCount regex_ptr =
    alloca $ \n_ptr -&gt; do
         c_pcre_fullinfo regex_ptr nullPtr info_capturecount n_ptr
         return . fromIntegral =&lt;&lt; peek (n_ptr :: Ptr CInt)</pre><p id="x_AJ1"><a name="x_AJ1"></a>
This takes a raw PCRE pointer and allocates space for the <code class="code">CInt</code>
count of the matched patterns. We then call the information function and
peek into the result structure, finding a <code class="code">CInt</code>. Finally, we
convert this to a normal Haskell <code class="code">Int</code> and pass it back to the
user.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id656311">Pattern matching with substrings</h3></div></div></div><p id="x_BJ1"><a name="x_BJ1"></a>
Let's now write the regex matching function. The Haskell type for matching
is similar to that for compiling regular expressions:
</p><a name="RegexExec.hs:exectype"></a><pre id="RegexExec.hs:exectype" class="programlisting">-- file: ch17/RegexExec.hs
match :: Regex -&gt; ByteString -&gt; [PCREExecOption] -&gt; Maybe [ByteString]</pre><p id="x_CJ1"><a name="x_CJ1"></a>
This function is how users will match strings against compiled regular
expressions. Again, the main design point is that it is a pure function.
Matching is a pure function: given the same input regular expression and
subject string, it will always return the same matched substrings. We convey
this information to the user via the type signature, indicating no side
effects will occure when you call this function.
</p><p id="x_DJ1"><a name="x_DJ1"></a>
The arguments are a compiled <code class="code">Regex</code>, a strict
<code class="code">ByteString</code>, containing the input data, and a list of
flags that modify the regular expression engine's behaviour at runtime. The result is
either no match at all, indicated by a <code class="code">Nothing</code> value, or just a
list of matched substrings. We use the <code class="code">Maybe</code> type to clearly
indicate in the type that matching may fail. By using strict <code class="code">ByteString</code>s for the
input data we can extract matched substrings in constant time, without
copying, making the interface rather efficient. If substrings are matched in
the input the offset vector is populated with pairs of integer offsets into
the subject string. We'll need to loop over this result vector, reading
offsets, and building <code class="code">ByteString</code> slices as we go.
</p><p id="x_EJ1"><a name="x_EJ1"></a>
The implementation of the match wrapper can be broken into three parts.  At
the top level, our function takes apart the compiled <code class="code">Regex</code>
structure, yielding the underlying <code class="code">PCRE</code> pointer:
</p><a name="RegexExec.hs:matchtop"></a><pre id="RegexExec.hs:matchtop" class="programlisting">-- file: ch17/RegexExec.hs
match :: Regex -&gt; ByteString -&gt; [PCREExecOption] -&gt; Maybe [ByteString]
match (Regex pcre_fp _) subject os = unsafePerformIO $ do
  withForeignPtr pcre_fp $ \pcre_ptr -&gt; do
    n_capt &lt;- capturedCount pcre_ptr

    let ovec_size = (n_capt + 1) * 3
        ovec_bytes = ovec_size * sizeOf (undefined :: CInt)</pre><p id="x_FJ1"><a name="x_FJ1"></a>
As it is pure, we can use <code class="code">unsafePerformIO</code> to hide any allocation
effects internally. After pattern matching on the <code class="code">PCRE</code> type, we
need to take apart the <code class="code">ForeignPtr</code> that hides our C-allocated raw
PCRE data. We can use <code class="code">withForeignPtr</code>. This holds on to the
Haskell data associated with the PCRE value while the call is being made,
preventing it from being collected for at least the time it is used by this
call. We then call the information function, and use that value to compute
the size of the offset vector (the formula for which is given in the PCRE
documentation). The number of bytes we need is the number of elements
multiplied by the size of a <code class="code">CInt</code>. To portably compute C type
sizes, the <code class="code">Storable</code> class provides a <code class="code">sizeOf</code>
function, that takes some arbitrary value of the required type (and we can
use the <code class="code">undefined</code> value here to do our type dispatch).
</p><p id="x_GJ1"><a name="x_GJ1"></a>
The next step is to allocate an offset vector of the size we computed, to
convert the input <code class="code">ByteString</code> into a pointer to a C
<code class="code">char</code> array. Finally, we call <code class="code">pcre_exec</code> with all the
required arguments:
</p><a name="RegexExec.hs:alloc"></a><pre id="RegexExec.hs:alloc" class="programlisting">-- file: ch17/RegexExec.hs
    allocaBytes ovec_bytes $ \ovec -&gt; do

        let (str_fp, off, len) = toForeignPtr subject
        withForeignPtr str_fp $ \cstr -&gt; do
            r &lt;- c_pcre_exec
                         pcre_ptr
                         nullPtr
                         (cstr `plusPtr` off)
                         (fromIntegral len)
                         0
                         (combineExecOptions os)
                         ovec
                         (fromIntegral ovec_size)</pre><p id="x_HJ1"><a name="x_HJ1"></a>
For the offset vector, we use <code class="code">allocaBytes</code> to control exactly
the size of the allocated array. It is like <code class="code">alloca</code>, but rather
than using the <code class="code">Storable</code> class to determine the required size,
it takes an explicit size in bytes to allocate. Taking apart
<code class="code">ByteString</code>'s, yielding the underlying pointer to memory they
contain, is done with <code class="code">toForeignPtr</code>, which converts our nice
<code class="code">ByteString</code> type into a managed pointer. Using
<code class="code">withForeignPtr</code> on the result gives us a raw <code class="code">Ptr CChar</code>,
which is exactly what we need to pass the input string to C. Programming in
Haskell is often just solving a type puzzle!
</p><p id="x_IJ1"><a name="x_IJ1"></a>
We then just call <code class="code">c_pcre_exec</code> with the raw PCRE pointer, the
input string pointer at the correct offset, its length, and the result vector
pointer. A status code is returned, and, finally, we analyse the result:
</p><a name="RegexExec.hs:results"></a><pre id="RegexExec.hs:results" class="programlisting">-- file: ch17/RegexExec.hs
            if r &lt; 0
                then return Nothing
                else let loop n o acc =
                            if n == r
                              then return (Just (reverse acc))
                              else do
                                    i &lt;- peekElemOff ovec o
                                    j &lt;- peekElemOff ovec (o+1)
                                    let s = substring i j subject
                                    loop (n+1) (o+2) (s : acc)
                     in loop 0 0 []

  where
    substring :: CInt -&gt; CInt -&gt; ByteString -&gt; ByteString
    substring x y _ | x == y = empty
    substring a b s = end
        where
            start = unsafeDrop (fromIntegral a) s
            end   = unsafeTake (fromIntegral (b-a)) start</pre><p id="x_JJ1"><a name="x_JJ1"></a>
If the result value was less than zero, then there was an error, or no match,
so we return <code class="code">Nothing</code> to the user. Otherwise, we need a loop
peeking pairs of offsets from the offset vector (via <code class="code">peekElemOff</code>).
Those offsets are used to find the matched substrings. To build substrings we
use a helper function that, given a start and end offset, drops the
surrounding portions of the subject string, yielding just the matched
portion. The loop runs until it has extracted the number of substrings we
were told were found by the matcher.
</p><p id="x_KJ1"><a name="x_KJ1"></a>
The substrings are accumulated in a tail recursive loop, building up a
reverse list of each string. Before returning the substrings of the user,
we need to flip that list around and wrap it in a successful
<code class="code">Just</code> tag. Let's try it out!
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id656609">The real deal: compiling and matching regular expressions</h3></div></div></div><p id="x_LJ1"><a name="x_LJ1"></a>
If we take this function, its surrounding hsc2hs definitions and data
wrappers, and process it with hsc2hs, we can load the resulting Haskell file
in GHCi and try out our code (we need to import
<code class="code">Data.ByteString.Char8</code> so we can build <code class="code">ByteString</code>s
from string literals):
</p><pre id="id656632" class="screen">
<code class="prompt">$ </code><strong class="userinput"><code>hsc2hs Regex.hsc</code></strong>
<code class="prompt">$ </code><strong class="userinput"><code>ghci Regex.hs -lpcre</code></strong>
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>:t compile</code></strong>
compile :: ByteString -&gt; [PCREOption] -&gt; Either String Regex
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>:t match</code></strong>
match :: Regex -&gt; ByteString -&gt; Maybe [ByteString]
</pre><p id="x_MJ1"><a name="x_MJ1"></a>
Things seem to be in order. Now let's try some compilation and matching.
First, something easy:
</p><pre id="id656689" class="screen">
<code class="prompt">*Regex&gt; </code><strong class="userinput"><code>:m + Data.ByteString.Char8</code></strong>
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>let Right r = compile (pack "the quick brown fox") []</code></strong>
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>match r (pack "the quick brown fox") []</code></strong>
Just ["the quick brown fox"]
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>match r (pack "The Quick Brown Fox") []</code></strong>
Nothing
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>match r (pack "What
  do you know about the quick brown fox?") []</code></strong>
Just ["the quick brown fox"]
</pre><p id="x_NJ1"><a name="x_NJ1"></a>
(We could also avoid the <code class="code">pack</code> calls by using the
<code class="code">OverloadedStrings</code> extensions). Or we can be more adventurous:
</p><pre id="id656765" class="screen">
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>let Right r = compile (pack "a*abc?xyz+pqr{3}ab{2,}xy{4,5}pq{0,6}AB{0,}zz") []</code></strong>
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>match r (pack "abxyzpqrrrabbxyyyypqAzz") []</code></strong>
Just ["abxyzpqrrrabbxyyyypqAzz"]
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>let Right r = compile (pack "^([^!]+)!(.+)=apquxz\\.ixr\\.zzz\\.ac\\.uk$") []</code></strong>
<code class="prompt">*Regex Data.ByteString.Char8&gt; </code><strong class="userinput"><code>match r (pack "abc!pqr=apquxz.ixr.zzz.ac.uk") []</code></strong>
Just ["abc!pqr=apquxz.ixr.zzz.ac.uk","abc","pqr"]
</pre><p id="x_OJ1"><a name="x_OJ1"></a>
That's pretty awesome. The full power of Perl regular expressions, in Haskell at your fingertips.
</p><p id="x_PJ1"><a name="x_PJ1"></a>
In this chapter we've looked at how to declare bindings that let Haskell code
call C functions, how to marshal different data types between the two
languages, how to allocate memory at a low level (by allocating locally, or
via C's memory management), and how to automate much of the hard work of
dealing with C by exploiting the Haskell type system and garbage collector.
Finally, we looked at how FFI preprocessors can ease much of the labour of
constructing new bindings. The result is a natural Haskell API, that is
actually implemented primarily in C.
</p><p id="x_QJ1"><a name="x_QJ1"></a>
The majority of FFI tasks fall into the above categories. Other advanced
techniques that we are unable to cover include: linking Haskell into C
programs, registering callbacks from one language to another, and the
<code class="code">c2hs</code> preprocessing tool. More information about these topics can
be found online.
</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id654015" href="#id654015" class="para">36</a>] </sup>Some more advanced binding tools provide greater degrees of
type checking. For example, <code class="code">c2hs</code> is able to parse the C
header, and generate the binding definition for you, and is especially
suited for large projects where the full API is specified. 
</p></div></div></div><div class="rwhfooter"><p><img src="/support/figs/rss.png"> Want to stay up to date? Subscribe to the comment feed for <a id="chapterfeed" class="feed" href="/feeds/comments/">this chapter</a>, or the <a class="feed" href="/feeds/comments/">entire book</a>.</p><p>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart, and
      John Goerzen. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
      Commons Attribution-Noncommercial 3.0 License</a>. Icons by <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.</p></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using-parsec.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="monad-transformers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 16. Using Parsec </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 18. Monad transformers</td></tr></table></div><script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-1805907-3"; urchinTracker();</script></body></html>
