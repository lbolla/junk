<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Why functional programming? Why Haskell?</title><link rel="stylesheet" href="/support/styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Real World Haskell"><link rel="up" href="index.html" title="Real World Haskell"><link rel="prev" href="index.html" title="Real World Haskell"><link rel="next" href="getting-started.html" title="Chapter 1. Getting Started"><link rel="alternate" type="application/atom+xml" title="Comments" href="/feeds/comments/"><link rel="shortcut icon" type="image/png" href="/support/figs/favicon.png"><script type="text/javascript" src="/support/jquery-min.js"></script><script type="text/javascript" src="/support/form.js"></script><script type="text/javascript" src="/support/hsbook.js"></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Why functional programming?  Why Haskell?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="getting-started.html">Next</a></td></tr></table></div><div class="preface" lang="en" id="whyfp"><div class="titlepage"><div><div><h2 class="title">Why functional programming?  Why Haskell?</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#id528893">Have we got a deal for you!</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id528233">Novelty</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id563635">Power</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id529125">Enjoyment</a></span></dt></dl></dd><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#id529185">What to expect from this book</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id528412">A little bit about you</a></span></dt></dl></dd><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#id528460">What to expect from Haskell</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id528487">Compared to traditional static languages</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id572991">Compared to modern dynamic languages</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573062">Haskell in industry and open source</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573188">Compilation, debugging, and performance analysis</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573275">Bundled and third party libraries</a></span></dt></dl></dd><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#id573401">A brief sketch of Haskell's history</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573413">Prehistory</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573451">Early antiquity</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573493">The modern era</a></span></dt></dl></dd><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#whyfp.resources">Helpful resources</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#whyfp.resources.reference">Reference material</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#whyfp.resources.apps">Applications and libraries</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#whyfp.resources.community">The Haskell community</a></span></dt></dl></dd><dt><span class="sect1"><a href="why-functional-programming-why-haskell.html#id573806">Acknowledgments</a></span></dt><dd><dl><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573825">Bryan</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573859">John</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573887">Don</a></span></dt><dt><span class="sect2"><a href="why-functional-programming-why-haskell.html#id573920">Thank you to our reviewers</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id528893">Have we got a deal for you!</h2></div></div></div><p id="x_Jx"><a name="x_Jx"></a>Haskell is a deep language, and we think that learning it is
      a hugely rewarding experience.  We will focus on three elements
      as we explain why. The first is
      <span class="emphasis"><em>novelty</em></span>: we invite you to think about
      programming from a different and valuable perspective.  The
      second is <span class="emphasis"><em>power</em></span>: we'll show you how to
      create software that is short, fast, and safe.  Lastly, we offer
      you a lot of <span class="emphasis"><em>fun</em></span>: the pleasure of applying
      beautiful programming techniques to solve real problems.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id528233">Novelty</h3></div></div></div><p id="x_Kx"><a name="x_Kx"></a>Haskell is most likely quite different from any language
	you've ever used before.  Compared to the usual set of
	concepts in a programmer's mental toolbox, functional
	programming offers us a profoundly different way to
	think about software.</p><p id="x_Lx"><a name="x_Lx"></a>In Haskell, we de-emphasise code that modifies
	data.  Instead, we focus on functions that take immutable
	values as input and produce new values as output. Given the
	same inputs, these functions always return the same results.
	This is a core idea behind functional programming.</p><p id="x_Mx"><a name="x_Mx"></a>Along with not modifying data, our Haskell
	functions usually don't talk to the external world; we call
	these functions <span class="emphasis"><em>pure</em></span>.  We make a strong
	distinction between pure code and the parts of our programs
	that read or write files, communicate over network
	connections, or make robot arms move.  This makes it easier to
	organize, reason about, and test our programs.</p><p id="x_Nx"><a name="x_Nx"></a>We abandon some ideas that might seem
	fundamental, such as having a <code class="code">for</code> loop built into
	the language.  We have other, more flexible, ways to perform
	repetitive tasks.</p><p id="x_Ox"><a name="x_Ox"></a>Even the way in which we evaluate expressions is
	different in Haskell.  We defer every computation until its
	result is actually needed: Haskell is a
	<span class="emphasis"><em>lazy</em></span> language. Laziness is not merely a
	matter of moving work around: it profoundly affects how we
	write programs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id563635">Power</h3></div></div></div><p id="x_Px"><a name="x_Px"></a>Throughout this book, we will show you how
	Haskell's alternatives to the features of traditional
	languages are powerful, flexible, and lead to reliable code.
	Haskell is positively crammed full of cutting edge ideas about
	how to create great software.</p><p id="x_Rx"><a name="x_Rx"></a>Since pure code has no dealings with the outside
	world, and the data it works with is never modified, the kinds
	of nasty surprise in which one piece of code invisibly
	corrupts data used by another are very rare. Whatever context
	we use a pure function in, it will behave consistently.</p><p id="x_Sx"><a name="x_Sx"></a>Pure code is easier to test than code that deals
	with the outside world.  When a function only responds to its
	visible inputs, we can easily state properties of its
	behavior that should always be true.  We can automatically
	test that those properties hold for a huge body of random
	inputs, and when our tests pass, we move on.  We still use
	traditional techniques to test code that must interact with
	files, networks, or exotic hardware.  Since there is much less
	of this impure code than we would find in a traditional
	language, we gain much more assurance that our software is
	solid.</p><p id="x_Tx"><a name="x_Tx"></a>Lazy evaluation has some spooky effects.  Let's
	say we want to find the <span class="emphasis"><em>k</em></span> least-valued
	elements of an unsorted list.  In a traditional language, the
	obvious approach would be to sort the list and take the first
	<span class="emphasis"><em>k</em></span> elements, but this is expensive.  For
	efficiency, we would instead write a special function that
	takes these values in one pass, and it would have to perform
	some moderately complex book-keeping.  In Haskell, the
	sort-then-take approach actually performs well: laziness
	ensures that the list will only be sorted enough to find the
	<span class="emphasis"><em>k</em></span> minimal elements.</p><p id="x_Ux"><a name="x_Ux"></a>Better yet, our Haskell code that operates so efficiently
	is tiny, and uses standard library functions.</p><a name="KMinima.hs:minima"></a><pre id="KMinima.hs:minima" class="programlisting">-- file: ch00/KMinima.hs
-- lines beginning with "--" are comments.

minima k xs = take k (sort xs)</pre><p id="x_Vx"><a name="x_Vx"></a>It can take a while to develop an intuitive feel
	for when lazy evaluation is important, but when we exploit it,
	the resulting code is often clean, brief, and
	efficient.</p><p id="x_Wx"><a name="x_Wx"></a>As the above example shows, an important aspect
	of Haskell's power lies in the compactness of the code we
	write. Compared to working in popular traditional languages,
	when we develop in Haskell we often write much less code, in
	substantially less time, and with fewer bugs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id529125">Enjoyment</h3></div></div></div><p id="x_Xx"><a name="x_Xx"></a>We believe that it is easy to pick up the basics of
	Haskell programming, and that you will be able to successfully
	write small programs within a matter of hours or days.</p><p id="x_Yx"><a name="x_Yx"></a>Since effective programming in Haskell differs
	greatly from other languages, you should expect that mastering
	both the language itself and functional programming techniques
	will require plenty of thought and practice.</p><p id="x_Zx"><a name="x_Zx"></a>Harking back to our own days of getting started with
	Haskell, the good news is that the fun begins early: it's
	simply an entertaining challenge to dig into a new language,
	in which so many commonplace ideas are different or missing,
	and to figure out how to write simple programs.</p><p id="x_ax"><a name="x_ax"></a>For us, the initial pleasure lasted as our
	experience grew and our understanding deepened.  In other
	languages, it's difficult to see any connection between
	science and the nuts-and-bolts of programming. In Haskell, we
	have imported some ideas from abstract mathematics and put
	them to work.  Even better, we find that not only are these
	ideas easy to pick up, they have a practical payoff in helping
	us to write more compact, reusable code.</p><p id="x_bx"><a name="x_bx"></a>Furthermore, we won't be putting any “<span class="quote">brick
	  walls</span>” in your way: there are no especially difficult
	or gruesome techniques in this book that you must master in
	order to be able to program effectively.</p><p id="x_cx"><a name="x_cx"></a>That being said, Haskell is a rigorous language:
	it will make you perform more of your thinking up front.  It
	can take a little while to adjust to debugging much of your
	code before you ever run it, in response to the compiler
	telling you that something about your program does not make
	sense.  Even with years of experience, we remain astonished and
	pleased by how often our Haskell programs simply work on the
	first try, once we fix those compilation errors.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id529185">What to expect from this book</h2></div></div></div><p id="x_Tl"><a name="x_Tl"></a>We started this project because a growing number
      of people are using Haskell to solve everyday problems. Because
      Haskell has its roots in academia, few of the Haskell books that
      currently exist focus on the problems and techniques of everyday
      programming that we're interested in.</p><p id="x_Rl"><a name="x_Rl"></a>With this book, we want to show you how to use
      functional programming and Haskell to solve realistic problems.
      This is a hands-on book: every chapter contains dozens of code
      samples, and many contain complete applications.  Here are a few
      examples of the libraries, techniques and tools that we'll show you
      how to develop.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_dx"><a name="x_dx"></a>Create an application that downloads podcast episodes
	  from the Internet, and stores its history in an SQL
	  database.</p></li><li><p id="x_ex"><a name="x_ex"></a>Test your code in an intuitive and powerful
	  way.  Describe properties that ought to be true, then let
	  the QuickCheck library generate test cases
	  automatically.</p></li><li><p id="x_fx"><a name="x_fx"></a>Take a grainy phone camera snapshot of a barcode, and
	  turn it into an identifier that you can use to query a
	  library or bookseller's web site.</p></li><li><p id="x_gx"><a name="x_gx"></a>Write code that thrives on the web.  Exchange
	  data with servers and clients written in other languages
	  using JSON notation.  Develop a concurrent link
	  checker.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id528412">A little bit about you</h3></div></div></div><p id="x_hx"><a name="x_hx"></a>What will you need to know before reading this
	book?  We expect that you already know how to program, but if
	you've never used a functional language, that's fine.</p><p id="x_ix"><a name="x_ix"></a>No matter what your level of experience is, we
	have tried to anticipate your needs: we go out of our way to
	explain new and potentially tricky ideas in depth, usually
	with examples and images to drive our points home.</p><p id="x_P"><a name="x_P"></a>As a new Haskell programmer, you'll inevitably
	start out writing quite a bit of code by hand for which you
	could have used a library function or programming technique,
	had you just known of its existence.  We've packed this book
	with information to help you to come up to speed as quickly as
	possible.</p><p id="x_jx"><a name="x_jx"></a>Of course, there will always be a few bumps along the
	road.  If you start out anticipating an occasional surprise or
	difficulty along with the fun stuff, you will have the best
	experience.  Any rough patches you might hit won't last
	long.</p><p id="x_kx"><a name="x_kx"></a>As you become a more seasoned Haskell programmer, the way
	that you write code will change.  Indeed, over the course of
	this book, the way that we present code will evolve, as we
	move from the basics of the language to increasingly powerful
	and productive features and techniques.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id528460">What to expect from Haskell</h2></div></div></div><p id="x_lx"><a name="x_lx"></a>Haskell is a general purpose programming language.  It was
      designed without any application niche in mind.  Although it
      takes a strong stand on how programs should be written, it does
      not favour one problem domain over others.</p><p id="x_mx"><a name="x_mx"></a>While at its core, the language encourages a pure, lazy
      style of functional programming, this is the
      <span class="emphasis"><em>default</em></span>, not the only option.  Haskell also
      supports the more traditional models of procedural code and
      strict evaluation.  Additionally, although the focus of the
      language is squarely on writing statically typed programs, it is
      possible (though rarely seen) to write Haskell code in a
      dynamically typed manner.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id528487">Compared to traditional static languages</h3></div></div></div><p id="x_nx"><a name="x_nx"></a>Languages that use simple static type systems
	have been the mainstay of the programming world for decades.
	Haskell is statically typed, but its notion of what types are
	for, and what we can do with them, is much more flexible and
	powerful than traditional languages.  Types make a major
	contribution to the brevity, clarity, and efficiency of
	Haskell programs.</p><p id="x_ox"><a name="x_ox"></a>Although powerful, Haskell's type system is
	often also unobtrusive.  If we omit explicit type information,
	a Haskell compiler will automatically infer the type of an
	expression or function. Compared to traditional static
	languages, to which we must spoon-feed large amounts of type
	information, the combination of power and inference in
	Haskell's type system significantly reduces the clutter and
	redundancy of our code.</p><p id="x_px"><a name="x_px"></a>Several of Haskell's other features combine to
	further increase the amount of work we can fit into a
	screenful of text.  This brings improvements in development
	time and agility: we can create reliable code quickly, and
	easily refactor it in response to changing
	requirements.</p><p id="x_qx"><a name="x_qx"></a>Sometimes, Haskell programs may run more slowly
	than similar programs written in C or C++.  For most of the
	code we write, Haskell's large advantages in productivity and
	reliability outweigh any small performance
	disadvantage.</p><p id="x_mA1"><a name="x_mA1"></a>Multicore processors are now ubiquitous, but they remain
	notoriously difficult to program using traditional techniques.
	Haskell provides unique technologies to make multicore
	programming more tractable.  It supports parallel programming,
	software transactional memory for reliable concurrency, and
	scales to hundreds of thousands of concurrent threads.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id572991">Compared to modern dynamic languages</h3></div></div></div><p id="x_sx"><a name="x_sx"></a>Over the past decade, dynamically typed, interpreted
	languages have become increasingly popular.  They offer
	substantial benefits in developer productivity.  Although this
	often comes at the cost of a huge performance hit, for
	many programming tasks productivity trumps performance, or
	performance isn't a significant factor in any case.</p><p id="x_tx"><a name="x_tx"></a>Brevity is one area in which Haskell and dynamically typed
	languages perform similarly: in each case, we write much less
	code to solve a problem than in a traditional language.
	Programs are often around the same size in dynamically typed
	languages and Haskell.</p><p id="x_ux"><a name="x_ux"></a>When we consider runtime performance, Haskell
	almost always has a huge advantage.  Code compiled by the
	Glasgow Haskell Compiler (<span class="application">GHC</span>) is typically between 20 and
	60 times faster than code run through a dynamic language's
	interpreter.  <span class="application">GHC</span> also provides an interpreter, so you can
	run scripts without compiling them.</p><p id="x_vx"><a name="x_vx"></a>Another big difference between dynamically typed
	languages and Haskell lies in their philosophies around types.  A
	major reason for the popularity of dynamically typed languages
	is that only rarely do we need to explicitly mention types.
	Through automatic type inference, Haskell offers the same
	advantage.</p><p id="x_wx"><a name="x_wx"></a>Beyond this surface similarity, the differences run
	deep.  In a dynamically typed language, we can create
	constructs that are difficult to express in a
	statically typed language.  However, the same is true in
	reverse: with a type system as powerful as Haskell's, we can
	structure a program in a way that would be unmanageable or
	infeasible in a dynamically typed language.</p><p id="x_xx"><a name="x_xx"></a>It's important to recognise that each of these approaches
	involves tradeoffs.  Very briefly put, the Haskell perspective
	emphasises safety, while the dynamically typed outlook favours
	flexibility.  If someone had already discovered one way of
	thinking about types that was always best, we imagine that
	everyone would know about it by now.</p><p id="x_yx"><a name="x_yx"></a>Of course, we have our own opinions about which tradeoffs
	are more beneficial.  Two of us have years of experience
	programming in dynamically typed languages.  We love working
	with them; we still use them every day; but usually, we prefer
	Haskell.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573062">Haskell in industry and open source</h3></div></div></div><p id="x_zx"><a name="x_zx"></a>Here are just a few examples of large software systems
	that have been created in Haskell.  Some of these are open
	source, while others are proprietary products.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_By"><a name="x_By"></a>ASIC and FPGA design software (Lava,
	    products from Bluespec Inc.)</p></li><li><p id="x_Cy"><a name="x_Cy"></a>Music composition software (Haskore)</p></li><li><p id="x_Ay"><a name="x_Ay"></a>Compilers and compiler-related tools (most
	    notably <span class="application">GHC</span>)</p></li><li><p id="x_Dy"><a name="x_Dy"></a>Distributed revision control (Darcs)</p></li><li><p id="x_Ey"><a name="x_Ey"></a>Web middleware (HAppS, products from Galois
	    Inc.)</p></li></ul></div><p id="x_nA1"><a name="x_nA1"></a> is a sample of some of the companies using Haskell in
	late 2008, taken from the <a class="ulink" href="http://www.haskell.org/haskellwiki/Haskell_in_industry" target="_top">Haskell 
	  wiki</a>.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_oA1"><a name="x_oA1"></a>ABN AMRO is an international bank. It uses Haskell in
	    investment banking, to measure the counterparty risk on
	    portfolios of financial derivatives. </p></li><li><p id="x_pA1"><a name="x_pA1"></a>Anygma is a startup company.  It develops multimedia
	    content creation tools using Haskell.</p></li><li><p id="x_qA1"><a name="x_qA1"></a>Amgen is a biotech company. It creates mathematical
	    models and other complex applications in Haskell.</p></li><li><p id="x_rA1"><a name="x_rA1"></a>Bluespec is an ASIC and FPGA design software vendor.
	    Its products are developed in Haskell, and the chip design
	    languages that its products provide are influenced by
	    Haskell.</p></li><li><p id="x_sA1"><a name="x_sA1"></a>Eaton uses Haskell for the design and verification of
	    hydraulic hybrid vehicle systems.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573188">Compilation, debugging, and performance analysis</h3></div></div></div><p id="x_Fy"><a name="x_Fy"></a>For practical work, almost as important as a language
	itself is the ecosystem of libraries and tools around it.
	Haskell has a strong showing in this area.</p><p id="x_Gy"><a name="x_Gy"></a>The most widely used compiler, <span class="application">GHC</span>, has been actively
	developed for over 15 years, and provides a mature and stable
	set of features.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_Hy"><a name="x_Hy"></a>Compiles to efficient native code on all major
	    modern operating systems and CPU architectures</p></li><li><p id="x_Iy"><a name="x_Iy"></a>Easy deployment of compiled binaries, unencumbered by
	    licensing restrictions</p></li><li><p id="x_Ky"><a name="x_Ky"></a>Code coverage analysis</p></li><li><p id="x_Ly"><a name="x_Ly"></a>Detailed profiling of performance and memory
	    usage</p></li><li><p id="x_My"><a name="x_My"></a>Thorough documentation</p></li><li><p id="x_Ny"><a name="x_Ny"></a>Massively scalable support for concurrent and
	    multicore programming</p></li><li><p id="x_Jy"><a name="x_Jy"></a>Interactive interpreter and debugger</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573275">Bundled and third party libraries</h3></div></div></div><p id="x_Oy"><a name="x_Oy"></a>The <span class="application">GHC</span> compiler ships with a collection of useful
	libraries.  Here are a few of the common programming needs
	that these libraries address.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_Py"><a name="x_Py"></a>File I/O, and filesystem traversal and
	  manipulation</p></li><li><p id="x_Qy"><a name="x_Qy"></a>Network client and server programming</p></li><li><p id="x_Ry"><a name="x_Ry"></a>Regular expressions and parsing</p></li><li><p id="x_Sy"><a name="x_Sy"></a>Concurrent programming</p></li><li><p id="x_Ty"><a name="x_Ty"></a>Automated testing</p></li><li><p id="x_Uy"><a name="x_Uy"></a>Sound and graphics</p></li></ul></div><p id="x_Vy"><a name="x_Vy"></a>The Hackage package database is the Haskell community's
	collection of open source libraries and applications.  Most
	libraries published on Hackage are licensed under liberal
	terms that permit both commercial and open source use.  Some
	of the areas covered by open source libraries include the
	following.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_Wy"><a name="x_Wy"></a>Interfaces to all major open source and commercial
	    databases</p></li><li><p id="x_Xy"><a name="x_Xy"></a>XML, HTML, and XQuery processing</p></li><li><p id="x_Yy"><a name="x_Yy"></a>Network and web client and server development</p></li><li><p id="x_Zy"><a name="x_Zy"></a>Desktop GUIs, including cross-platform toolkits</p></li><li><p id="x_ay"><a name="x_ay"></a>Support for Unicode and other text encodings</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id573401">A brief sketch of Haskell's history</h2></div></div></div><p id="x_by"><a name="x_by"></a>The development of Haskell is rooted in
      mathematics and computer science research.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573413">Prehistory</h3></div></div></div><p id="x_cy"><a name="x_cy"></a>A few decades before modern computers were
	invented, the mathematician Alonzo Church developed a language
	called the lambda calculus.  He intended it as a tool for
	investigating the foundations of mathematics.  The first
	person to realize the practical connection between programming
	and the lambda calculus was John McCarthy, who created Lisp in
	1958.</p><p id="x_dy"><a name="x_dy"></a>During the 1960s, computer scientists began to recognise
	and study the importance of the lambda calculus.  Peter Landin
	and Christopher Strachey developed ideas about the foundations
	of programming languages: how to reason about what they do
	(operational semantics) and how to understand what they mean
	(denotational semantics).</p><p id="x_ey"><a name="x_ey"></a>In the early 1970s, Robin Milner created a more rigorous
	functional programming language named ML.  While ML was
	developed to help with automated proofs of mathematical
	theorems, it gained a following for more general computing
	tasks.</p><p id="x_fy"><a name="x_fy"></a>The 1970s saw the emergence of lazy evaluation as a novel
	strategy.  David Turner developed SASL and KRC, while Rod
	Burstall and John Darlington developed NPL and Hope.  NPL,
	KRC and ML influenced the development of several more
	languages in the 1980s, including Lazy ML, Clean, and
	Miranda.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573451">Early antiquity</h3></div></div></div><p id="x_gy"><a name="x_gy"></a>By the late 1980s, the efforts of researchers working on
	lazy functional languages were scattered across more than a
	dozen languages.  Concerned by this diffusion of effort, a
	number of researchers decided to form a committee to design a
	common language.  After three years of work, the committee
	published the Haskell 1.0 specification in 1990.  It named the
	language after Haskell Curry, an influential logician.</p><p id="x_hy"><a name="x_hy"></a>Many people are rightfully suspicious of
	“<span class="quote">design by committee</span>”, but the work of the
	Haskell committee is a beautiful example of the best work a
	committee can do.  They produced an elegant, considered
	language design, and succeeded in unifying the fractured
	efforts of their research community.  Of the thicket of lazy
	functional languages that existed in 1990, only Haskell is
	still actively used.</p><p id="x_iy"><a name="x_iy"></a>Since its publication in 1990, the Haskell
	language standard has seen five revisions, most recently in
	1998. A number of Haskell implementations have been written,
	and several are still actively developed.</p><p id="x_jy"><a name="x_jy"></a>During the 1990s, Haskell served two main
	purposes.  On one side, it gave language researchers a stable
	language in which to experiment with making lazy functional
	programs run efficiently.  Other researchers explored how to
	construct programs using lazy functional techniques.  Still
	others used it as a teaching language.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573493">The modern era</h3></div></div></div><p id="x_ky"><a name="x_ky"></a>While these basic explorations of the 1990s
	proceeded, Haskell remained firmly an academic affair.  The
	informal slogan of those inside the community was to
	“<span class="quote">avoid success at all costs</span>”. Few outsiders had
	heard of the language at all.  Indeed, functional programming
	as a field was quite obscure.</p><p id="x_ly"><a name="x_ly"></a>During this time, the mainstream programming
	world experimented with relatively small tweaks: from
	programming in C, to C++, to Java.  Meanwhile, on the fringes,
	programmers were beginning to tinker with new, more dynamic
	languages. Guido van Rossum designed Python; Larry Wall
	created Perl; and Yukihiro Matsumoto developed Ruby.</p><p id="x_my"><a name="x_my"></a>As these newer languages began to seep into
	wider use, they spread some crucial ideas. The first was that
	programmers are not merely capable of working in expressive
	languages; in fact, they flourish.  The second was in part a
	byproduct of the rapid growth in raw computing power of that
	era: it's often smart to sacrifice some execution performance
	in exchange for a big increase in programmer productivity.
	Finally, several of these languages borrowed from functional
	programming.</p><p id="x_ny"><a name="x_ny"></a>Over the past half a decade, Haskell has successfully
	escaped from academia, buoyed in part by the visibility of
	Python, Ruby, and even Javascript.  The language now has a
	vibrant and fast-growing culture of open source and commercial
	users, and researchers continue to use it to push the
	boundaries of performance and expressiveness.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="whyfp.resources">Helpful resources</h2></div></div></div><p id="x_Ul"><a name="x_Ul"></a>
      As you work with Haskell, you're sure to have questions and want
      more information about things.  Here are some Internet resources
      where you can look up information and interact with other
      Haskell programmers.
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="whyfp.resources.reference">Reference material</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p id="x_Vl"><a name="x_Vl"></a><a class="ulink" href="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html" target="_top">The 
	      Haskell Hierarchical Libraries reference</a>
	    provides the documentation for the standard library that comes
	    with your compiler.  This is one of the most valuable
	    online assets for Haskell programmers.</p></li><li><p id="x_Wl"><a name="x_Wl"></a>For questions about language syntax and
	    features, the <a class="ulink" href="http://haskell.org/onlinereport/" target="_top">Haskell 98
	      Report</a> describes the Haskell 98 language
	    standard.</p></li><li><p id="x_Xl"><a name="x_Xl"></a>Various extensions to the language have
	    become commonplace since the Haskell 98 Report was
	    released.  The <a class="ulink" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html" target="_top"><span class="application">GHC</span> 
	      Users's Guide</a> contains detailed documentation on
	    the extensions supported by <span class="application">GHC</span>, as well as some
	    GHC-specific features.</p></li><li><p id="x_Yl"><a name="x_Yl"></a><a class="ulink" href="http://haskell.org/hoogle/" target="_top">Hoogle</a> and
	    <a class="ulink" href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_top">Hayoo</a> 
	    are Haskell API search engines.  They can search for
	    functions by name or by type.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="whyfp.resources.apps">Applications and libraries</h3></div></div></div><p id="x_Zl"><a name="x_Zl"></a>
        If you're looking for a Haskell library to use for a
        particular task, or an application written in Haskell, check
        out the following resources.
      </p><div class="itemizedlist"><ul type="disc"><li><p id="x_al"><a name="x_al"></a>The Haskell community maintains a central
	    repository of open source Haskell libraries and
	    applications.  It's called <a class="ulink" href="http://hackage.haskell.org/" target="_top">Hackage</a>, and
	    it lets you search for software to download, or browse its
	    collection by category.</p></li><li><p id="x_bl"><a name="x_bl"></a>The <a class="ulink" href="http://haskell.org/haskellwiki/Applications_and_libraries" target="_top">Haskell 
	      Wiki</a> contains a section dedicated to information
	    about particular Haskell libraries.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="whyfp.resources.community">The Haskell community</h3></div></div></div><p id="x_cl"><a name="x_cl"></a>There are a number of ways you can get in touch
	with other Haskell programmers, to ask questions, learn what
	other people are talking about, and simply do some social
	networking with your peers.</p><div class="itemizedlist"><ul type="disc"><li><p id="x_dl"><a name="x_dl"></a>The first stop on your search for community
	    resources should be the <a class="ulink" href="http://www.haskell.org/" target="_top">Haskell web site</a>.
	    This page contains the most current links to various
	    communities and information, as well as a huge and
	    actively maintained wiki.</p></li><li><p id="x_el"><a name="x_el"></a>Haskellers use a number of <a class="ulink" href="http://haskell.org/haskellwiki/Mailing_lists" target="_top">mailing 
	      lists</a> for topical discussions.  Of these, the
	    most generally interesting is named
	    <code class="code">haskell-cafe</code>.  It has a relaxed,
	    friendly atmosphere, where professionals and academics rub
	    shoulders with casual hackers and beginners.</p></li><li><p id="x_fl"><a name="x_fl"></a>For real-time chat, the <a class="ulink" href="http://haskell.org/haskellwiki/IRC_channel" target="_top">Haskell
	      IRC channel</a>, named <code class="code">#haskell</code>, is
	    large and lively.  Like <code class="code">haskell-cafe</code>, the
	    atmosphere stays friendly and helpful in spite of the huge
	    number of concurrent users.</p></li><li><p id="x_gl"><a name="x_gl"></a>There are many local user groups, meetups,
	    academic workshops, and the like; here is <a class="ulink" href="http://haskell.org/haskellwiki/User_groups" target="_top">a list
	      of the known user groups and workshops</a>.</p></li><li><p id="x_hl"><a name="x_hl"></a>The <a class="ulink" href="http://sequence.complete.org/" target="_top">Haskell Weekly
	      News</a> is a very-nearly-weekly summary of
	    activities in the Haskell community.  You can find
	    pointers to interesting mailing list discussions, new
	    software releases, and the like.</p></li><li><p id="x_il"><a name="x_il"></a>The <a class="ulink" href="http://haskell.org/communities/" target="_top">Haskell
	      Communities and Activities Report</a> collects
	    information about people that use Haskell, and what they
	    are doing with it.  It has been running for years, so it
	    provides a good way to peer into Haskell's past.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id573806">Acknowledgments</h2></div></div></div><p id="x_wN1"><a name="x_wN1"></a>This book would not exist without the Haskell community: an
      anarchic, hopeful cabal of artists, theoreticians and engineers,
      who for twenty years have worked to create a better, bug-free
      programming world. The people of the Haskell community are
      unique in their combination of friendliness and intellectual
      depth.</p><p id="x_xN1"><a name="x_xN1"></a>We wish to thank our editor, Mike Loukides, and the
      production team at O'Reilly for all of their advice and
      assistance.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573825">Bryan</h3></div></div></div><p id="x_yN1"><a name="x_yN1"></a>I had a great deal of fun working with John and Don. Their
	independence, good nature, and formidable talent made the
	writing process remarkably smooth.</p><p id="x_zN1"><a name="x_zN1"></a>Simon Peyton Jones took a chance on a college student who
	emailed him out of the blue in early 1994. Interning for him
	over that summer remains a highlight of my professional life.
	With his generosity, boundless energy, and drive to
	collaborate, he inspires the whole Haskell community.</p><p id="x_AO1"><a name="x_AO1"></a>My children, Cian and Ruairi, always stood ready to help
	me to unwind with wonderful, madcap little-boy games.</p><p id="x_BO1"><a name="x_BO1"></a>Finally, of course, I owe a great debt to my wife,
	Shannon, for her love, wisdom, and support during the long
	gestation of this book.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573859">John</h3></div></div></div><p id="x_CO1"><a name="x_CO1"></a>
        I am so glad to be able to work with Bryan and Don  on this project.
        The depth of their Haskell knowledge and experience is
        amazing.  I enjoyed finally being able to have the three of us
        sit down in the same room -- over a year after we started
        writing.
      </p><p id="x_ZO1"><a name="x_ZO1"></a>
        My 2-year-old Jacob, who decided that it would be fun to use a
        keyboard too, and is always eager to have me take a break from
        the computer and
        help him make some fun typing noises on a 50-year-old Underwood
        typewriter.
      </p><p id="x_aO1"><a name="x_aO1"></a>
        Most importantly, I wouldn't have ever been involved in this
        project without the love, support, and encouragement from my
        wife, Terah.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573887">Don</h3></div></div></div><p id="x_DO1"><a name="x_DO1"></a>Before all else, I'd like to thank my amazing
	co-conspirators, John and Bryan, for encouragment, advice and
	motivation.</p><p id="x_EO1"><a name="x_EO1"></a>My colleagues at Galois, Inc., who daily wield Haskell in
	the real world, provided regular feedback and war stories, and
	helped ensured a steady supply of espresso.</p><p id="x_FO1"><a name="x_FO1"></a>My PhD supervisor, Manuel Chakravarty, and the PLS
	research group, who provided encouragement, vision and energy,
	and showed me that a rigorous, foundational approach to
	programming can make the impossible happen.</p><p id="x_GO1"><a name="x_GO1"></a>And, finally, thanks to Suzie, for her insight, patience and
        love.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id573920">Thank you to our reviewers</h3></div></div></div><p id="x_HO1"><a name="x_HO1"></a>We developed this book in the open, posting drafts of
	chapters to our web site as we completed them. Readers then
	submitted feedback using a web application that we developed.
	By the time we finished writing the book, about 800 people had
	submitted over 7,500 comments, an astounding figure.</p><p id="x_IO1"><a name="x_IO1"></a>We deeply appreciate the time that so many people
	volunteered to help us to improve our book.  Their
	encouragement and enthusiasm over the 15 months we spent
	writing made the process a pleasure.</p><p id="x_JO1"><a name="x_JO1"></a>The breadth and depth of the comments we received have
	profoundly improved the quality of this book.  Nevertheless,
	all errors and omissions are, of course, ours.</p><p id="x_KO1"><a name="x_KO1"></a>The following people each contributed over 1% of the total
	number of review comments that we received.  We would like to
	thank them for their care in providing us with so much
	detailed feedback.</p><p id="x_LO1"><a name="x_LO1"></a>
	Alex Stangl,
	Andrew Bromage,
	Brent Yorgey,
	Bruce Turner,
	Calvin Smith,
	David Teller,
	Henry Lenzi,
	Jay Scott,
	John Dorsey,
	Justin Dressel,
	Lauri Pesonen,
	Lennart Augustsson,
	Luc Duponcheel,
	Matt Hellige,
	Michael T. Richter,
	Peter McLain,
	Rob deFriesse,
	Rüdiger Hanke,
	Tim Chevalier,
	Tim Stewart,
	William N. Halchin.
      </p><p id="x_MO1"><a name="x_MO1"></a>We are also grateful to the people below, each of whom
	contributed at least 0.2% of all comments.</p><p id="x_NO1"><a name="x_NO1"></a>
	Achim Schneider,
	Adam Jones,
	Alexander Semenov,
	Andrew Wagner,
	Arnar Birgisson,
	Arthur van Leeuwen,
	Bartek Ćwikłowski,
	Bas Kok,
	Ben Franksen,
	Björn Buckwalter,
	Brian Brunswick,
	Bryn Keller,
	Chris Holliday,
	Chris Smith,
	Dan Scott,
	Dan Weston,
	Daniel Larsson,
	Davide Marchignoli,
	Derek Elkins,
	Dirk Ullrich,
	Doug Kirk,
	Douglas Silas,
	Emmanuel Delaborde,
	Eric Lavigne,
	Erik Haugen,
	Erik Jones,
	Fred Ross,
	Geoff King,
	George Moschovitis,
	Hans van Thiel,
	Ionuț Arțăriși,
	Isaac Dupree,
	Isaac Freeman,
	Jared Updike,
	Joe Thornber,
	Joeri van Eekelen,
	Joey Hess,
	Johan Tibell,
	John Lenz,
	Josef Svenningsson,
	Joseph Garvin,
	Josh Szepietowski,
	Justin Bailey,
	Kai Gellien,
	Kevin Watters,
	Konrad Hinsen,
	Lally Singh,
	Lee Duhem,
	Luke Palmer,
	Magnus Therning,
	Marc DeRosa,
	Marcus Eskilsson,
	Mark Lee Smith,
	Matthew Danish,
	Matthew Manela,
	Michael Vanier,
	Mike Brauwerman,
	Neil Mitchell,
	Nick Seow,
	Pat Rondon,
	Raynor Vliegendhart,
	Richard Smith,
	Runar Bjarnason,
	Ryan W. Porter,
	Salvatore Insalaco,
	Sean Brewer,
	Sebastian Sylvan,
	Sebastien Bocq,
	Sengan Baring-Gould,
	Serge Le Huitouze,
	Shahbaz Chaudhary,
	Shawn M Moore,
	Tom Tschetter,
	Valery V. Vorotyntsev,
	Will Newton,
	Wolfgang Meyer,
	Wouter Swierstra.
      </p><p id="x_OO1"><a name="x_OO1"></a>We would like to acknowledge the following
	people, many of whom submitted a number of comments.</p><p id="x_PO1"><a name="x_PO1"></a>
	Aaron Hall,
	Abhishek Dasgupta,
	Adam Copp,
	Adam Langley,
	Adam Warrington,
	Adam Winiecki,
	Aditya Mahajan,
	Adolfo Builes,
	Al Hoang,
	Alan Hawkins,
	Albert Brown,
	Alec Berryman,
	Alejandro Dubrovsky,
	Alex Hirzel,
	Alex Rudnick,
	Alex Young,
	Alexander Battisti,
	Alexander Macdonald,
	Alexander Strange,
	Alf Richter,
	Alistair Bayley,
	Allan Clark,
	Allan Erskine,
	Allen Gooch,
	Andre Nathan,
	Andreas Bernstein,
	Andreas Schropp,
	Andrei Formiga,
	Andrew Butterfield,
	Andrew Calleja,
	Andrew Rimes,
	Andrew The,
	Andy Carson,
	Andy Payne,
	Angelos Sphyris,
	Ankur Sethi,
	António Pedro Cunha,
	Anthony Moralez,
	Antoine Hersen,
	Antoine Latter,
	Antoine S.,
	Antonio Cangiano,
	Antonio Piccolboni,
	Antonios Antoniadis,
	Antonis Antoniadis,
	Aristotle Pagaltzis,
	Arjen van Schie,
	Artyom Shalkhakov,
	Ash Logan,
	Austin Seipp,
	Avik Das,
	Avinash Meetoo,
	BVK Chaitanya,
	Babu Srinivasan,
	Barry Gaunt,
	Bas van Dijk,
	Ben Burdette,
	Ben Ellis,
	Ben Moseley,
	Ben Sinclair,
	Benedikt Huber,
	Benjamin Terry,
	Benoit Jauvin-Girard,
	Bernie Pope,
	Björn Edström,
	Bob Holness,
	Bobby Moretti,
	Boyd Adamson,
	Brad Ediger,
	Bradley Unterrheiner,
	Brendan J. Overdiep,
	Brendan Macmillan,
	Brett Morgan,
	Brian Bloniarz,
	Brian Lewis,
	Brian Palmer,
	Brice Lin,
	C Russell,
	Cale Gibbard,
	Carlos Aya,
	Chad Scherrer,
	Chaddaï Fouché,
	Chance Coble,
	Charles Krohn,
	Charlie Paucard,
	Chen Yufei,
	Cheng Wei,
	Chip Grandits,
	Chris Ball,
	Chris Brew,
	Chris Czub,
	Chris Gallagher,
	Chris Jenkins,
	Chris Kuklewicz,
	Chris Wright,
	Christian Lasarczyk,
	Christian Vest Hansen,
	Christophe Poucet,
	Chung-chieh Shan,
	Conal Elliott,
	Conor McBride,
	Conrad Parker,
	Cosmo Kastemaa,
	Creighton Hogg,
	Crutcher Dunnavant,
	Curtis Warren,
	D Hardman,
	Dafydd Harries,
	Dale Jordan,
	Dan Doel,
	Dan Dyer,
	Dan Grover,
	Dan Orias,
	Dan Schmidt,
	Dan Zwell,
	Daniel Chicayban Bastos,
	Daniel Karch,
	Daniel Lyons,
	Daniel Patterson,
	Daniel Wagner,
	Daniil Elovkov,
	Danny Yoo,
	Darren Mutz,
	Darrin Thompson,
	Dave Bayer,
	Dave Hinton,
	Dave Leimbach,
	Dave Peterson,
	Dave Ward,
	David Altenburg,
	David B. Wildgoose,
	David Carter,
	David Einstein,
	David Ellis,
	David Fox,
	David Frey,
	David Goodlad,
	David Mathers,
	David McBride,
	David Sabel,
	Dean Pucsek,
	Denis Bueno,
	Denis Volk,
	Devin Mullins,
	Diego Moya,
	Dino Morelli,
	Dirk Markert,
	Dmitry Astapov,
	Dougal Stanton,
	Dr Bean,
	Drew Smathers,
	Duane Johnson,
	Durward McDonell,
	E. Jones,
	Edwin DeNicholas,
	Emre Sevinc,
	Eric Aguiar,
	Eric Frey,
	Eric Kidd,
	Eric Kow,
	Eric Schwartz,
	Erik Hesselink,
	Erling Alf,
	Eruc Frey,
	Eugene Grigoriev,
	Eugene Kirpichov,
	Evan Farrer,
	Evan Klitzke,
	Evan Martin,
	Fawzi Mohamed,
	Filippo Tampieri,
	Florent Becker,
	Frank Berthold,
	Fred Rotbart,
	Frederick Ross,
	Friedrich Dominicus,
	Gal Amram,
	Ganesh Sittampalam,
	Gen Zhang,
	Geoffrey King,
	George Bunyan,
	George Rogers,
	German Vidal,
	Gilson Silveira,
	Gleb Alexeyev,
	Glenn Ehrlich,
	Graham Fawcett,
	Graham Lowe,
	Greg Bacon,
	Greg Chrystall,
	Greg Steuck,
	Grzegorz Chrupała,
	Guillaume Marceau,
	Haggai Eran,
	Harald Armin Massa,
	Henning Hasemann,
	Henry Laxen,
	Hitesh Jasani,
	Howard B. Golden,
	Ilmari Vacklin,
	Imam Tashdid ul Alam,
	Ivan Lazar Miljenovic,
	Ivan Miljenovic,
	J. Pablo Fernández,
	J.A. Zaratiegui,
	Jaap Weel,
	Jacques Richer,
	Jake McArthur,
	Jake Poznanski,
	Jakub Kotowski,
	Jakub Labath,
	James Cunningham,
	James Smith,
	Jamie Brandon,
	Jan Sabbe,
	Jared Roberts,
	Jason Dusek,
	Jason F,
	Jason Kikel,
	Jason Mobarak,
	Jason Morton,
	Jason Rogers,
	Jeff Balogh,
	Jeff Caldwell,
	Jeff Petkau,
	Jeffrey Bolden,
	Jeremy Crosbie,
	Jeremy Fitzhardinge,
	Jeremy O'Donoghue,
	Jeroen Pulles,
	Jim Apple,
	Jim Crayne,
	Jim Snow,
	Joan Jiménez,
	Joe Fredette,
	Joe Healy,
	Joel Lathrop,
	Joeri Samson,
	Johannes Laire,
	John Cowan,
	John Doe,
	John Hamilton,
	John Hornbeck,
	John Lien,
	John Stracke,
	Jonathan Guitton,
	Joseph Bruce,
	Joseph H. Buehler,
	Josh Goldfoot,
	Josh Lee,
	Josh Stone,
	Judah Jacobson,
	Justin George,
	Justin Goguen,
	Kamal Al-Marhubi,
	Kamil Dworakowski,
	Keegan Carruthers-Smith,
	Keith Fahlgren,
	Keith Willoughby,
	Ken Allen,
	Ken Shirriff,
	Kent Hunter,
	Kevin Hely,
	Kevin Scaldeferri,
	Kingdon Barrett,
	Kristjan Kannike,
	Kurt Jung,
	Lanny Ripple,
	Laurențiu Nicola,
	Laurie Cheers,
	Lennart Kolmodin,
	Liam Groener,
	Lin Sun,
	Lionel Barret de Nazaris,
	Loup Vaillant,
	Luke Plant,
	Lutz Donnerhacke,
	Maarten Hazewinkel,
	Malcolm Reynolds,
	Marco Piccioni,
	Mark Hahnenberg,
	Mark Woodward,
	Marko Tosic,
	Markus Schnell,
	Martijn van Egdom,
	Martin Bayer,
	Martin DeMello,
	Martin Dybdal,
	Martin Geisler,
	Martin Grabmueller,
	Matúš Tejiščák,
	Mathew Manela,
	Matt Brandt,
	Matt Russell,
	Matt Trinneer,
	Matti Niemenmaa,
	Matti Nykänen,
	Max Cantor,
	Maxime Henrion,
	Michael Albert,
	Michael Brauwerman,
	Michael Campbell,
	Michael Chermside,
	Michael Cook,
	Michael Dougherty,
	Michael Feathers,
	Michael Grinder,
	Michael Kagalenko,
	Michael Kaplan,
	Michael Orlitzky,
	Michael Smith,
	Michael Stone,
	Michael Walter,
	Michel Salim,
	Mikael Vejdemo Johansson,
	Mike Coleman,
	Mike Depot,
	Mike Tremoulet,
	Mike Vanier,
	Mirko Rahn,
	Miron Brezuleanu,
	Morten Andersen,
	Nathan Bronson,
	Nathan Stien,
	Naveen Nathan,
	Neil Bartlett,
	Neil Whitaker,
	Nick Gibson,
	Nick Messenger,
	Nick Okasinski,
	Nicola Paolucci,
	Nicolas Frisby,
	Niels Aan de Brugh,
	Niels Holmgaard Andersen,
	Nima Negahban,
	Olaf Leidinger,
	Oleg Anashkin,
	Oleg Dopertchouk,
	Oleg Taykalo,
	Oliver Charles,
	Olivier Boudry,
	Omar Antolín Camarena,
	Parnell Flynn,
	Patrick Carlisle,
	Paul Brown,
	Paul Delhanty,
	Paul Johnson,
	Paul Lotti,
	Paul Moore,
	Paul Stanley,
	Paulo Tanimoto,
	Per Vognsen,
	Pete Kazmier,
	Peter Aarestad,
	Peter Ipacs,
	Peter Kovaliov,
	Peter Merel,
	Peter Seibel,
	Peter Sumskas,
	Phil Armstrong,
	Philip Armstrong,
	Philip Craig,
	Philip Neustrom,
	Philip Turnbull,
	Piers Harding,
	Piet Delport,
	Pragya Agarwal,
	Raúl Gutiérrez,
	Rafael Alemida,
	Rajesh Krishnan,
	Ralph Glass,
	Rauli Ruohonen,
	Ravi Nanavati,
	Raymond Pasco,
	Reid Barton,
	Reto Kramer,
	Reza Ziaei,
	Rhys Ulerich,
	Ricardo Herrmann,
	Richard Harris,
	Richard Warburton,
	Rick van Hattem,
	Rob Grainger,
	Robbie Kop,
	Rogan Creswick,
	Roman Gonzalez,
	Rory Winston,
	Ruediger Hanke,
	Rusty Mellinger,
	Ryan Grant,
	Ryan Ingram,
	Ryan Janzen,
	Ryan Kaulakis,
	Ryan Stutsman,
	Ryan T. Mulligan,
	S Pai,
	Sam Lee,
	Sandy Nicholson,
	Scott Brickner,
	Scott Rankin,
	Scott Ribe,
	Sean Cross,
	Sean Leather,
	Sergei Trofimovich,
	Sergio Urinovsky,
	Seth Gordon,
	Seth Tisue,
	Shawn Boyette,
	Simon Brenner,
	Simon Farnsworth,
	Simon Marlow,
	Simon Meier,
	Simon Morgan,
	Sriram Srinivasan,
	Sriram Srinivasan,
	Stefan Aeschbacher,
	Stefan Muenzel,
	Stephan Friedrichs,
	Stephan Nies,
	Stephan-A. Posselt,
	Stephyn Butcher,
	Steven Ashley,
	Stuart Dootson,
	Terry Michaels,
	Thomas Cellerier,
	Thomas Fuhrmann,
	Thomas Hunger,
	Thomas M. DuBuisson,
	Thomas Moertel,
	Thomas Schilling,
	Thorsten Seitz,
	Tibor Simic,
	Tilo Wiklund,
	Tim Clark,
	Tim Eves,
	Tim Massingham,
	Tim Rakowski,
	Tim Wiess,
	Timo B. Hübel,
	Timothy Fitz,
	Tom Moertel,
	Tomáš Janoušek,
	Tony Colston,
	Travis B. Hartwell,
	Tristan Allwood,
	Tristan Seligmann,
	Tristram Brelstaff,
	Vesa Kaihlavirta,
	Victor Nazarov,
	Ville Aine,
	Vincent Foley,
	Vipul Ved Prakash,
	Vlad Skvortsov,
	Vojtěch Fried,
	Wei Cheng,
	Wei Hu,
	Will Barrett,
	Will Farr,
	Will Leinweber,
	Will Robertson,
	Will Thompson,
	Wirt Wolff,
	Wolfgang Jeltsch,
	Yuval Kogman,
	Zach Kozatek,
	Zachary Smestad,
	Zohar Kelrich.
      </p><p id="x_QO1"><a name="x_QO1"></a>Finally, we wish to thank those readers who submitted over
	800 comments anonymously.</p></div></div></div><div class="rwhfooter"><p><img src="/support/figs/rss.png"> Want to stay up to date? Subscribe to the comment feed for <a id="chapterfeed" class="feed" href="/feeds/comments/">this chapter</a>, or the <a class="feed" href="/feeds/comments/">entire book</a>.</p><p>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart, and
      John Goerzen. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
      Commons Attribution-Noncommercial 3.0 License</a>. Icons by <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.</p></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="getting-started.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Real World Haskell </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Getting Started</td></tr></table></div><script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-1805907-3"; urchinTracker();</script></body></html>
