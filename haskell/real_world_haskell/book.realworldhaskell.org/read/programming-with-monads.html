<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 15. Programming with monads</title><link rel="stylesheet" href="/support/styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="Real World Haskell"><link rel="up" href="index.html" title="Real World Haskell"><link rel="prev" href="monads.html" title="Chapter 14. Monads"><link rel="next" href="using-parsec.html" title="Chapter 16. Using Parsec"><link rel="alternate" type="application/atom+xml" title="Comments" href="/feeds/comments/"><link rel="shortcut icon" type="image/png" href="/support/figs/favicon.png"><script type="text/javascript" src="/support/jquery-min.js"></script><script type="text/javascript" src="/support/form.js"></script><script type="text/javascript" src="/support/hsbook.js"></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><h2 class="booktitle"><a href="/">Real World Haskell</a><span class="authors">by Bryan O'Sullivan, Don Stewart, and John Goerzen</span></h2></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 15. Programming with monads</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="monads.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="using-parsec.html">Next</a></td></tr></table></div><div class="chapter" lang="en" id="monadcase"><div class="titlepage"><div><div><h2 class="title">Chapter 15. Programming with monads</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="programming-with-monads.html#monadcase.urlencoded">Golfing practice: association lists</a></span></dt><dt><span class="sect1"><a href="programming-with-monads.html#monadcase.ap">Generalised lifting</a></span></dt><dt><span class="sect1"><a href="programming-with-monads.html#monadcase.monadplus">Looking for alternatives</a></span></dt><dd><dl><dt><span class="sect2"><a href="programming-with-monads.html#id646349">The name mplus does not imply addition</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id646449">Rules for working with MonadPlus</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id646526">Failing safely with MonadPlus</a></span></dt></dl></dd><dt><span class="sect1"><a href="programming-with-monads.html#id646649">Adventures in hiding the plumbing</a></span></dt><dd><dl><dt><span class="sect2"><a href="programming-with-monads.html#id647223">Supplying random numbers</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id647480">Another round of golf</a></span></dt></dl></dd><dt><span class="sect1"><a href="programming-with-monads.html#id647603">Separating interface from implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="programming-with-monads.html#monadcase.mptc">Multi-parameter typeclasses</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id647796">Functional dependencies</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id647987">Rounding out our module</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id648100">Programming to a monad's interface</a></span></dt></dl></dd><dt><span class="sect1"><a href="programming-with-monads.html#id648161">The reader monad</a></span></dt><dt><span class="sect1"><a href="programming-with-monads.html#id648430">A return to automated deriving</a></span></dt><dt><span class="sect1"><a href="programming-with-monads.html#id648782">Hiding the IO monad</a></span></dt><dd><dl><dt><span class="sect2"><a href="programming-with-monads.html#id648821">Using a newtype</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id649049">Designing for unexpected uses</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#monadcase.io.class">Using typeclasses</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id649416">Isolation and testing</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#monadcase.writer.dlist">The writer monad and lists</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id649728">Arbitrary I/O revisited</a></span></dt><dt><span class="sect2"><a href="programming-with-monads.html#id649843">Exercises</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="monadcase.urlencoded">Golfing practice: association lists</h2></div></div></div><p id="x_ki"><a name="x_ki"></a>Web clients and servers often pass information around as a
      simple textual list of key-value pairs.</p><pre id="id645453" class="programlisting">name=Attila+%42The+Hun%42&amp;occupation=Khan</pre><p id="x_li"><a name="x_li"></a>The encoding is named
      <code class="code">application/x-www-form-urlencoded</code>, and it's easy to
      understand.  Each key-value pair is separated by an
      “<span class="quote"><code class="code">&amp;</code></span>” character.  Within a pair, a
      key is a series of characters, followed by an
      “<span class="quote"><code class="code">=</code></span>”, followed by a value.</p><p id="x_mi"><a name="x_mi"></a>We can obviously represent a key as a <span class="type">String</span>,
      but the HTTP specification is not clear about whether a key must
      be followed by a value.  We can capture this ambiguity by
      representing a value as a <span class="type">Maybe String</span>.  If we use
      <code class="code">Nothing</code> for a value, then there was no value
      present.  If we wrap a string in <code class="code">Just</code>, then there
      was a value.  Using <span class="type">Maybe</span> lets us distinguish
      between “<span class="quote">no value</span>” and “<span class="quote">empty
	value</span>”.</p><p id="x_ni"><a name="x_ni"></a>Haskell programmers use the name <span class="emphasis"><em>association
	list</em></span> for the type <span class="type">[(a, b)]</span>, where we
      can think of each element as an association between a key and a
      value.  The name originates in the Lisp community, where it's
      usually abbreviated as an <span class="emphasis"><em>alist</em></span>.  We could
      thus represent the above string as the following Haskell
      value.</p><a name="MovieReview.hs:attila"></a><pre id="MovieReview.hs:attila" class="programlisting">-- file: ch15/MovieReview.hs
    [("name",       Just "Attila \"The Hun\""),
     ("occupation", Just "Khan")]</pre><p id="x_oi"><a name="x_oi"></a>In <a class="xref" href="using-parsec.html#applicative.urlencoded" title="Parsing an URL-encoded query string">the section called “Parsing an URL-encoded query string”</a>, we'll parse an
      <code class="code">application/x-www-form-urlencoded</code> string, and
      represent the result as an alist of <span class="type">[(String, Maybe
	String)]</span>.  Let's say we want to use one of these alists
      to fill out a data structure.</p><a name="MovieReview.hs:MovieReview"></a><pre id="MovieReview.hs:MovieReview" class="programlisting">-- file: ch15/MovieReview.hs
data MovieReview = MovieReview {
      revTitle :: String
    , revUser :: String
    , revReview :: String
    }</pre><p id="x_pi"><a name="x_pi"></a>We'll begin by belabouring the obvious with a naive
      function.</p><a name="MovieReview.hs:simpleReview"></a><pre id="MovieReview.hs:simpleReview" class="programlisting">-- file: ch15/MovieReview.hs
simpleReview :: [(String, Maybe String)] -&gt; Maybe MovieReview
simpleReview alist =
  case lookup "title" alist of
    Just (Just title@(_:_)) -&gt;
      case lookup "user" alist of
        Just (Just user@(_:_)) -&gt;
          case lookup "review" alist of
            Just (Just review@(_:_)) -&gt;
                Just (MovieReview title user review)
            _ -&gt; Nothing -- no review
        _ -&gt; Nothing -- no user
    _ -&gt; Nothing -- no title</pre><p id="x_qi"><a name="x_qi"></a>It only returns a <span class="type">MovieReview</span> if the alist
      contains all of the necessary values, and they're all non-empty
      strings.  However, the fact that it validates its inputs is its
      only merit: it suffers badly from the “<span class="quote">staircasing</span>”
      that we've learned to be wary of, and it knows the intimate
      details of the representation of an alist.</p><p id="x_ri"><a name="x_ri"></a>Since we're now well acquainted with the <span class="type">Maybe</span>
      monad, we can tidy up the staircasing.</p><a name="MovieReview.hs:maybeReview"></a><pre id="MovieReview.hs:maybeReview" class="programlisting">-- file: ch15/MovieReview.hs
maybeReview alist = do
    title &lt;- lookup1 "title" alist
    user &lt;- lookup1 "user" alist
    review &lt;- lookup1 "review" alist
    return (MovieReview title user review)

lookup1 key alist = case lookup key alist of
                      Just (Just s@(_:_)) -&gt; Just s
                      _ -&gt; Nothing</pre><p id="x_si"><a name="x_si"></a>Although this is much tidier, we're still repeating
      ourselves.  We can take advantage of the fact that the
      <code class="code">MovieReview</code> constructor acts as a normal, pure
      function by <span class="emphasis"><em>lifting</em></span> it into the monad, as
      we discussed in <a class="xref" href="monads.html#monads.liftM" title="Mixing pure and monadic code">the section called “Mixing pure and monadic code”</a>.</p><a name="MovieReview.hs:liftedReview"></a><pre id="MovieReview.hs:liftedReview" class="programlisting">-- file: ch15/MovieReview.hs
liftedReview alist =
    liftM3 MovieReview (lookup1 "title" alist)
                       (lookup1 "user" alist)
                       (lookup1 "review" alist)</pre><p id="x_oG1"><a name="x_oG1"></a>We still have some repetition here, but it is dramatically
      reduced, and also more difficult to remove.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="monadcase.ap">Generalised lifting</h2></div></div></div><p id="x_ti"><a name="x_ti"></a>Although using <code class="function">liftM3</code> tidies up our
      code, we can't use a <code class="function">liftM</code>-family function
      to solve this sort of problem in general, because they're only
      defined up to <code class="function">liftM5</code> by the standard
      libraries.  We could write variants up to whatever number we
      pleased, but that would amount to drudgery.</p><p id="x_pG1"><a name="x_pG1"></a>If we had a constructor or pure function that took, say, ten
      parameters, and decided to stick with the standard libraries you
      might think we'd be out of luck.</p><p id="x_ui"><a name="x_ui"></a>Of course, our toolbox isn't yet empty.  In
      <code class="code">Control.Monad</code>, there's a function named
      <code class="function">ap</code> with an interesting type
      signature.</p><a name="ap.ghci:ap"></a><pre id="ap.ghci:ap" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +Control.Monad</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type ap</code></strong>
ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</pre><p id="x_vi"><a name="x_vi"></a>You might wonder who would put a single-argument pure
      function inside a monad, and why.  Recall, however, that
      <span class="emphasis"><em>all</em></span> Haskell functions really take only one
      argument, and you'll begin to see how this might relate to the
      <code class="code">MovieReview</code> constructor.</p><a name="ap.ghci:MovieReview"></a><pre id="ap.ghci:MovieReview" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type MovieReview</code></strong>
MovieReview :: String -&gt; String -&gt; String -&gt; MovieReview
</pre><p id="x_wi"><a name="x_wi"></a>We can just as easily write that type as <span class="type">String -&gt;
	(String -&gt; (String -&gt; MovieReview))</span>.  If we use
      plain old <code class="function">liftM</code> to lift
      <code class="code">MovieReview</code> into the <code class="code">Maybe</code> monad,
      we'll have a value of type <span class="type">Maybe (String -&gt; (String
	-&gt; (String -&gt; MovieReview)))</span>.  We can now see
      that this type is suitable as an argument for
      <code class="function">ap</code>, in which case the result type will be
      <span class="type">Maybe (String -&gt; (String -&gt; MovieReview))</span>. We
      can pass this, in turn, to <code class="function">ap</code>, and continue
      to chain until we end up with this definition.</p><a name="MovieReview.hs:apReview"></a><pre id="MovieReview.hs:apReview" class="programlisting">-- file: ch15/MovieReview.hs
apReview alist =
    MovieReview `liftM` lookup1 "title" alist
                   `ap` lookup1 "user" alist
                   `ap` lookup1 "review" alist</pre><p id="x_xi"><a name="x_xi"></a>We can chain applications of
      <code class="function">ap</code> like this as many times as we need to,
      thereby bypassing the <code class="function">liftM</code> family of
      functions.</p><p id="x_yi"><a name="x_yi"></a>Another helpful way to look at
      <code class="function">ap</code> is that it's the monadic equivalent of
      the familiar <code class="function">($)</code> operator: think of
      pronouncing <code class="function">ap</code> as
      <span class="emphasis"><em>apply</em></span>.  We can see this clearly when we
      compare the type signatures of the two functions.</p><a name="ap.ghci:types"></a><pre id="ap.ghci:types" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type ($)</code></strong>
($) :: (a -&gt; b) -&gt; a -&gt; b
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type ap</code></strong>
ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</pre><p id="x_qG1"><a name="x_qG1"></a>In fact, <code class="function">ap</code> is usually defined as
      either <code class="code">liftM2 id</code> or <code class="code">liftM2 ($)</code>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="monadcase.monadplus">Looking for alternatives</h2></div></div></div><p id="x_zi"><a name="x_zi"></a>Here's a simple representation of a person's phone
      numbers.</p><a name="VCard.hs:numbers"></a><pre id="VCard.hs:numbers" class="programlisting">-- file: ch15/VCard.hs
data Context = Home | Mobile | Business
               deriving (Eq, Show)

type Phone = String

albulena = [(Home, "+355-652-55512")]

nils = [(Mobile, "+47-922-55-512"), (Business, "+47-922-12-121"),
        (Home, "+47-925-55-121"), (Business, "+47-922-25-551")]

twalumba = [(Business, "+260-02-55-5121")]</pre><p id="x_Aj"><a name="x_Aj"></a>Suppose we want to get in touch with someone to make a
      personal call.  We don't want their business number, and we'd
      prefer to use their home number (if they have one) instead of
      their mobile number.</p><a name="VCard.hs:personalPhone"></a><pre id="VCard.hs:personalPhone" class="programlisting">-- file: ch15/VCard.hs
onePersonalPhone :: [(Context, Phone)] -&gt; Maybe Phone
onePersonalPhone ps = case lookup Home ps of
                        Nothing -&gt; lookup Mobile ps
                        Just n -&gt; Just n</pre><p id="x_Bj"><a name="x_Bj"></a>Of course, if we use <span class="type">Maybe</span> as the result type,
      we can't accommodate the possibility that someone might have
      more than one number that meet our criteria.  For that, we
      switch to a list.</p><a name="VCard.hs:businessPhones"></a><pre id="VCard.hs:businessPhones" class="programlisting">-- file: ch15/VCard.hs
allBusinessPhones :: [(Context, Phone)] -&gt; [Phone]
allBusinessPhones ps = map snd numbers
    where numbers = case filter (contextIs Business) ps of
                      [] -&gt; filter (contextIs Mobile) ps
                      ns -&gt; ns

contextIs a (b, _) = a == b</pre><p id="x_Cj"><a name="x_Cj"></a>Notice that these two functions structure their <code class="literal">case</code>
      expressions similarly: one alternative handles the case where
      the first lookup returns an empty result, while the other
      handles the non-empty case.</p><a name="vcard.ghci:simple"></a><pre id="vcard.ghci:simple" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>onePersonalPhone twalumba</code></strong>
Nothing
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>onePersonalPhone albulena</code></strong>
Just "+355-652-55512"
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>allBusinessPhones nils</code></strong>
["+47-922-12-121","+47-922-25-551"]
</pre><p id="x_Dj"><a name="x_Dj"></a>Haskell's <code class="code">Control.Monad</code> module defines a
      typeclass, <span class="type">MonadPlus</span>, that lets us abstract the
      common pattern out of our <code class="literal">case</code> expressions.</p><a name="VCard.hs:MonadPlus"></a><pre id="VCard.hs:MonadPlus" class="programlisting">-- file: ch15/VCard.hs
class Monad m =&gt; MonadPlus m where
   mzero :: m a	
   mplus :: m a -&gt; m a -&gt; m a</pre><p id="x_Ej"><a name="x_Ej"></a>The value <code class="code">mzero</code> represents an empty result,
      while <code class="function">mplus</code> combines two results into one.
      Here are the standard definitions of <code class="code">mzero</code> and
      <code class="function">mplus</code> for <span class="type">Maybe</span> and
      lists.</p><a name="VCard.hs:instances"></a><pre id="VCard.hs:instances" class="programlisting">-- file: ch15/VCard.hs
instance MonadPlus [] where
   mzero = []
   mplus = (++)

instance MonadPlus Maybe where
   mzero = Nothing

   Nothing `mplus` ys  = ys
   xs      `mplus` _ = xs</pre><p id="x_Fj"><a name="x_Fj"></a>We can now use <code class="function">mplus</code> to get
      rid of our <code class="literal">case</code> expressions entirely.  For variety, let's
      fetch one business and all personal phone numbers.</p><a name="VCard.hs:caseless"></a><pre id="VCard.hs:caseless" class="programlisting">-- file: ch15/VCard.hs
oneBusinessPhone :: [(Context, Phone)] -&gt; Maybe Phone
oneBusinessPhone ps = lookup Business ps `mplus` lookup Mobile ps

allPersonalPhones :: [(Context, Phone)] -&gt; [Phone]
allPersonalPhones ps = map snd $ filter (contextIs Home) ps `mplus`
                                 filter (contextIs Mobile) ps</pre><p id="x_Gj"><a name="x_Gj"></a>In these functions, because we know that
      <code class="function">lookup</code> returns a value of type
      <span class="type">Maybe</span>, and <code class="function">filter</code> returns a
      list, it's obvious which version of <code class="function">mplus</code>
      is going to be used in each case.</p><p id="x_Hj"><a name="x_Hj"></a>What's more interesting is that we can use
      <code class="code">mzero</code> and <code class="function">mplus</code> to write
      functions that will be useful for <span class="emphasis"><em>any</em></span>
      <span class="type">MonadPlus</span> instance.  As an example, here's the
      standard <code class="function">lookup</code> function, which returns a
      value of type <span class="type">Maybe</span>.</p><a name="VCard.hs:lookup"></a><pre id="VCard.hs:lookup" class="programlisting">-- file: ch15/VCard.hs
lookup :: (Eq a) =&gt; a -&gt; [(a, b)] -&gt; Maybe b
lookup _ []                      = Nothing
lookup k ((x,y):xys) | x == k    = Just y
                     | otherwise = lookup k xys</pre><p id="x_Ij"><a name="x_Ij"></a>We can easily generalise the result type to any instance of
      <span class="type">MonadPlus</span> as follows.</p><a name="VCard.hs:lookupM"></a><pre id="VCard.hs:lookupM" class="programlisting">-- file: ch15/VCard.hs
lookupM :: (MonadPlus m, Eq a) =&gt; a -&gt; [(a, b)] -&gt; m b
lookupM _ []    = mzero
lookupM k ((x,y):xys)
    | x == k    = return y `mplus` lookupM k xys
    | otherwise = lookupM k xys</pre><p id="x_Jj"><a name="x_Jj"></a>This lets us get either no result or one, if our result type
      is <span class="type">Maybe</span>; all results, if our result type is a
      list; or something more appropriate for some other exotic instance
      of <span class="type">MonadPlus</span>.</p><p id="x_rG1"><a name="x_rG1"></a>For small functions, such as those we present above, there's
      little benefit to using <code class="function">mplus</code>.  The
      advantage lies in more complex code and in code that is
      independent of the monad in which it executes.  Even if you
      don't find yourself needing <span class="type">MonadPlus</span> for your own
      code, you are likely to encounter it in other people's
      projects.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id646349">The name mplus does not imply addition</h3></div></div></div><p id="x_Kj"><a name="x_Kj"></a>Even though the <code class="function">mplus</code> function
	contains the text “<span class="quote">plus</span>”, you should not think of
	it as necessarily implying that we're trying to add two
	values.</p><p id="x_Lj"><a name="x_Lj"></a>Depending on the monad we're working in,
	<code class="function">mplus</code> <span class="emphasis"><em>may</em></span> implement an
	operation that looks like addition.  For example,
	<code class="function">mplus</code> in the list monad is implemented as
	the <code class="function">(++)</code> operator.</p><a name="monadPlus.ghci:list.mplus"></a><pre id="monadPlus.ghci:list.mplus" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>[1,2,3] `mplus` [4,5,6]</code></strong>
[1,2,3,4,5,6]
</pre><p id="x_Mj"><a name="x_Mj"></a>However, if we switch to another monad, the obvious
	similarity to addition falls away.</p><a name="monadPlus.ghci:maybe.mplus"></a><pre id="monadPlus.ghci:maybe.mplus" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>Just 1 `mplus` Just 2</code></strong>
Just 1
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id646449">Rules for working with MonadPlus</h3></div></div></div><p id="x_Nj"><a name="x_Nj"></a>Instances of the <span class="type">MonadPlus</span> typeclass must
	follow a few  simple rules, in addition to the usual monad
	rules.</p><p id="x_Oj"><a name="x_Oj"></a>An instance must <span class="emphasis"><em>short circuit</em></span> if
	<code class="code">mzero</code> appears on the left of a bind expression.
	In other words, an expression <code class="code">mzero &gt;&gt;= f</code>
	must evaluate to the same result as <code class="code">mzero</code>
	alone.</p><a name="MonadPlus.hs:shortcircuitLeft"></a><pre id="MonadPlus.hs:shortcircuitLeft" class="programlisting">-- file: ch15/MonadPlus.hs
    mzero &gt;&gt;= f == mzero</pre><p id="x_Pj"><a name="x_Pj"></a>An instance must short circuit if <code class="code">mzero</code>
	appears on the <span class="emphasis"><em>right</em></span> of a sequence
	expression.</p><a name="MonadPlus.hs:shortcircuitRight"></a><pre id="MonadPlus.hs:shortcircuitRight" class="programlisting">-- file: ch15/MonadPlus.hs
    v &gt;&gt; mzero == mzero</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id646526">Failing safely with MonadPlus</h3></div></div></div><p id="x_Qj"><a name="x_Qj"></a>When we introduced the <code class="function">fail</code> function in <a class="xref" href="monads.html#monads.class" title="The Monad typeclass">the section called “The Monad typeclass”</a>, we took pains to warn against its
	use: in many monads, it's implemented as a call to <code class="function">error</code>,
	which has unpleasant consequences.</p><p id="x_Rj"><a name="x_Rj"></a>The <span class="type">MonadPlus</span> typeclass gives us a gentler
	way to fail a computation, without <code class="function">fail</code> or <code class="function">error</code> blowing
	up in our faces.  The rules that we introduced above allow us
	to introduce an <code class="code">mzero</code> into our code wherever we
	need to, and computation will short circuit at that
	point.</p><p id="x_Sj"><a name="x_Sj"></a>In the <code class="code">Control.Monad</code> module, the standard
	function <code class="function">guard</code> packages up this idea in a
	convenient form.</p><a name="MonadPlus.hs:guard"></a><pre id="MonadPlus.hs:guard" class="programlisting">-- file: ch15/MonadPlus.hs
guard        :: (MonadPlus m) =&gt; Bool -&gt; m ()
guard True   =  return ()
guard False  =  mzero</pre><p id="x_Tj"><a name="x_Tj"></a>As a simple example, here's a function that takes a number
	<code class="varname">x</code> and computes its value modulo some other
	number <code class="varname">n</code>.  If the result is zero, it
	returns <code class="varname">x</code>, otherwise the current monad's
	<code class="code">mzero</code>.</p><a name="MonadPlus.hs:zeroMod"></a><pre id="MonadPlus.hs:zeroMod" class="programlisting">-- file: ch15/MonadPlus.hs
x `zeroMod` n = guard ((x `mod` n) == 0) &gt;&gt; return x</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id646649">Adventures in hiding the plumbing</h2></div></div></div><p id="x_wq"><a name="x_wq"></a>In <a class="xref" href="monads.html#monads.state.random" title="Using the state monad: generating random values">the section called “Using the state monad: generating random values”</a>, we showed how to
      use the <span class="type">State</span> monad to give ourselves access to
      random numbers in a way that is easy to use.</p><p id="x_xq"><a name="x_xq"></a>A drawback of the code we developed is that it's
      <span class="emphasis"><em>leaky</em></span>: someone who uses it knows that
      they're executing inside the <span class="type">State</span> monad.  This
      means that they can inspect and modify the state of the random
      number generator just as easily as we, the authors, can.</p><p id="x_yq"><a name="x_yq"></a>Human nature dictates that if we leave our internal workings
      exposed, someone will surely come along and monkey with them.
      For a sufficiently small program, this may be fine, but in a
      larger software project, when one consumer of a library modifies
      its internals in a way that other consumers are not prepared
      for, the resulting bugs can be among the hardest of all to track
      down.  These bugs occur at a level where we're unlikely to
      question our basic assumptions about a library until long after
      we've exhausted all other avenues of inquiry.</p><p id="x_zq"><a name="x_zq"></a>Even worse, once we leave our implementation exposed for a
      while, and some well-intentioned person inevitably bypasses our
      APIs and uses the implementation directly, we create a nasty
      quandary for ourselves if we need to fix a bug or make an
      enhancement.  Either we can modify our internals, and break code
      that depends on them; or we're stuck with our existing
      internals, and must try to find some other way to make the
      change we need.</p><p id="x_Ar"><a name="x_Ar"></a>How can we revise our random number monad so that the fact
      that we're using the <span class="type">State</span> monad is hidden?  We
      need to somehow prevent our users from being able to call
      <code class="code">get</code> or <code class="code">put</code>.  This is not difficult to
      do, and it introduces some tricks that we'll reuse often in
      day-to-day Haskell programming.</p><p id="x_Br"><a name="x_Br"></a>To widen our scope, we'll move beyond random numbers, and
      implement a monad that supplies unique values of
      <span class="emphasis"><em>any</em></span> kind.  The name we'll give to our monad
      is <span class="type">Supply</span>.  We'll provide the execution function,
      <code class="function">runSupply</code>, with a list of values; it will
      be up to us to ensure that each one is unique.</p><a name="Supply.hs:runSupply.type"></a><pre id="Supply.hs:runSupply.type" class="programlisting">-- file: ch15/Supply.hs
runSupply :: Supply s a -&gt; [s] -&gt; (a, [s])</pre><p id="x_Cr"><a name="x_Cr"></a>The monad won't care what the values are: they might be
      random numbers, or names for temporary files, or identifiers for
      HTTP cookies.</p><p id="x_Dr"><a name="x_Dr"></a>Within the monad, every time a consumer asks for a value,
      the <code class="function">next</code> action will take the next one from
      the list and give it to the consumer.  Each value is wrapped in
      a <span class="type">Maybe</span> constructor in case the list isn't long
      enough to satisfy the demand.</p><a name="Supply.hs:next.type"></a><pre id="Supply.hs:next.type" class="programlisting">-- file: ch15/Supply.hs
next :: Supply s (Maybe s)</pre><p id="x_Er"><a name="x_Er"></a>To hide our plumbing, in our module declaration we only
      export the type constructor, the execution function, and the
      <code class="function">next</code> action.</p><a name="Supply.hs:module"></a><pre id="Supply.hs:module" class="programlisting">-- file: ch15/Supply.hs
module Supply
    (
      Supply
    , next
    , runSupply
    ) where</pre><p id="x_Fr"><a name="x_Fr"></a>Since a module that imports the library can't see the
      internals of the monad, it can't manipulate them.</p><p id="x_Gr"><a name="x_Gr"></a>Our plumbing is exceedingly simple: we use a <code class="code">newtype</code>
      declaration to wrap the existing <span class="type">State</span>
      monad.</p><a name="Supply.hs:Supply"></a><pre id="Supply.hs:Supply" class="programlisting">-- file: ch15/Supply.hs
import Control.Monad.State

newtype Supply s a = S (State [s] a)</pre><p id="x_Hr"><a name="x_Hr"></a>The <code class="varname">s</code> parameter is the type
      of the unique values we are going to supply, and <code class="varname">a</code> is the usual type parameter that
      we must provide in order to make our type a monad.</p><p id="x_Ir"><a name="x_Ir"></a>Our use of <code class="code">newtype</code> for the <span class="type">Supply</span>
      type and our module header join forces to prevent our clients
      from using the <span class="type">State</span> monad's
      <code class="function">get</code> and <code class="function">set</code> actions.
      Because our module does not export the <code class="code">S</code> data
      constructor, clients have no programmatic way to see that we're
      wrapping the <span class="type">State</span> monad, or to access it.</p><p id="x_Jr"><a name="x_Jr"></a>At this point, we've got a type, <span class="type">Supply</span>, that
      we need to make an instance of the <span class="type">Monad</span> type
      class.  We could follow the usual pattern of defining <code class="function">(&gt;&gt;=)</code> and
      <code class="literal">return</code>, but this would be pure boilerplate code.  All we'd be
      doing is wrapping and unwrapping the <span class="type">State</span> monad's
      versions of <code class="function">(&gt;&gt;=)</code> and <code class="literal">return</code> using our <code class="code">S</code> value
      constructor.  Here is how such code would look.</p><a name="AltSupply.hs:unwrapS"></a><pre id="AltSupply.hs:unwrapS" class="programlisting">-- file: ch15/AltSupply.hs
unwrapS :: Supply s a -&gt; State [s] a
unwrapS (S s) = s

instance Monad (Supply s) where
    s &gt;&gt;= m = S (unwrapS s &gt;&gt;= unwrapS . m)
    return = S . return</pre><p id="x_Kr"><a name="x_Kr"></a>Haskell programmers are not fond of boilerplate, and sure
      enough, <span class="application">GHC</span> has a lovely language extension that eliminates
      the work. To use it, we add the following directive to the top
      of our source file, before the module header.</p><a name="Supply.hs:LANGUAGE"></a><pre id="Supply.hs:LANGUAGE" class="programlisting">-- file: ch15/Supply.hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}</pre><p id="x_Lr"><a name="x_Lr"></a>Usually, we can only automatically derive instances of a
      handful of standard typeclasses, such as <span class="type">Show</span> and
      <span class="type">Eq</span>.  As its name suggests, the
      <code class="code">GeneralizedNewtypeDeriving</code> extension broadens our
      ability to derive typeclass instances, and it is specific to
      <code class="code">newtype</code> declarations.  If the type we're wrapping is an
      instance of any typeclass, the extensions can
      automatically make our new type an instance of that typeclass
      as follows.</p><a name="Supply.hs:deriving"></a><pre id="Supply.hs:deriving" class="programlisting">-- file: ch15/Supply.hs
    deriving (Monad)</pre><p id="x_Mr"><a name="x_Mr"></a>This takes the underlying type's implementations of <code class="function">(&gt;&gt;=)</code>
      and <code class="literal">return</code>, adds the necessary wrapping and unwrapping with
      our <code class="code">S</code> data constructor, and uses the new versions
      of those functions to derive a <span class="type">Monad</span> instance for
      us.</p><p id="x_Nr"><a name="x_Nr"></a>What we gain here is very useful beyond just this example.
      We can use <code class="code">newtype</code> to wrap any underlying type; we selectively
      expose only those typeclass instances that we want; and we
      expend almost no effort to create these narrower, more
      specialised types.</p><p id="x_Or"><a name="x_Or"></a>Now that we've seen the
      <code class="code">GeneralizedNewtypeDeriving</code> technique, all that
      remains is to provide definitions of <code class="function">next</code>
      and <code class="function">runSupply</code>.</p><a name="Supply.hs:code"></a><pre id="Supply.hs:code" class="programlisting">-- file: ch15/Supply.hs
next = S $ do st &lt;- get
              case st of
                [] -&gt; return Nothing
                (x:xs) -&gt; do put xs
                             return (Just x)

runSupply (S m) xs = runState m xs</pre><p id="x_Pr"><a name="x_Pr"></a>If we load our module into <span class="command"><strong>ghci</strong></span>, we can try it out in a few
      simple ways.</p><a name="supply.ghci:simple"></a><pre id="supply.ghci:simple" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:load Supply</code></strong>
[1 of 1] Compiling Supply           ( Supply.hs, interpreted )
Ok, modules loaded: Supply.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runSupply next [1,2,3]</code></strong>
Loading package mtl-1.1.0.0 ... linking ... done.
(Just 1,[2,3])
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runSupply (liftM2 (,) next next) [1,2,3]</code></strong>
((Just 1,Just 2),[3])
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runSupply (liftM2 (,) next next) [1]</code></strong>
((Just 1,Nothing),[])
</pre><p id="x_Qr"><a name="x_Qr"></a>We can also verify that the <span class="type">State</span> monad has not
      somehow leaked out.</p><a name="supply.ghci:browse"></a><pre id="supply.ghci:browse" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:browse Supply</code></strong>
data Supply s a
next :: Supply s (Maybe s)
runSupply :: Supply s a -&gt; [s] -&gt; (a, [s])
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:info Supply</code></strong>
data Supply s a 	-- Defined at Supply.hs:17:8-13
instance Monad (Supply s) -- Defined at Supply.hs:17:8-13
</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id647223">Supplying random numbers</h3></div></div></div><p id="x_Rr"><a name="x_Rr"></a>If we want to use our <span class="type">Supply</span> monad as a
	source of random numbers, we have a small difficulty to face.
	Ideally, we'd like to be able to provide it with an infinite
	stream of random numbers.  We can get a <span class="type">StdGen</span> in
	the <span class="type">IO</span> monad, but we must “<span class="quote">put back</span>”
	a different <span class="type">StdGen</span> when we're done.  If we don't,
	the next piece of code to get a <span class="type">StdGen</span> will get
	the same state as we did.  This means it will generate the
	same random numbers as we did, which is potentially
	catastrophic.</p><p id="x_Sr"><a name="x_Sr"></a>From the parts of the <code class="code">System.Random</code>
	module we've seen so far, it's difficult to reconcile these
	demands. We can use <code class="function">getStdRandom</code>, whose
	type ensures that when we get a <span class="type">StdGen</span>, we put
	one back.</p><a name="randomSupply.ghci:getStdRandom"></a><pre id="randomSupply.ghci:getStdRandom" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type getStdRandom</code></strong>
getStdRandom :: (StdGen -&gt; (a, StdGen)) -&gt; IO a
</pre><p id="x_sG1"><a name="x_sG1"></a>We can use <code class="function">random</code> to get back a new
	<span class="type">StdGen</span> when they give us a random number.  And we
	can use <code class="function">randoms</code> to get an infinite list
	of random numbers.  But how do we get both an infinite list of
	random numbers <span class="emphasis"><em>and</em></span> a new
	<span class="type">StdGen</span>?</p><p id="x_Tr"><a name="x_Tr"></a>The answer lies with the <span class="type">RandomGen</span> type
	class's <code class="function">split</code> function, which takes one
	random number generator, and turns it into two generators.
	Splitting a random generator like this is a most unusual thing
	to be able to do: it's obviously tremendously useful in a pure
	functional setting, but essentially never either necessary or
	provided by an impure language.</p><p id="x_Ur"><a name="x_Ur"></a>Using the <code class="function">split</code> function, we can use
	one <span class="type">StdGen</span> to generate an infinite list of random
	numbers to feed to <code class="function">runSupply</code>, while we
	give the other back to the <span class="type">IO</span> monad.</p><a name="RandomSupply.hs:randomsIO"></a><pre id="RandomSupply.hs:randomsIO" class="programlisting">-- file: ch15/RandomSupply.hs
import Supply
import System.Random hiding (next)

randomsIO :: Random a =&gt; IO [a]
randomsIO =
    getStdRandom $ \g -&gt;
        let (a, b) = split g
        in (randoms a, b)</pre><p id="x_Vr"><a name="x_Vr"></a>If we've written this function properly, our
	example ought to print a different random number on each
	invocation.</p><a name="randomSupply.ghci:random"></a><pre id="randomSupply.ghci:random" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:load RandomSupply</code></strong>
[1 of 2] Compiling Supply           ( Supply.hs, interpreted )
[2 of 2] Compiling RandomSupply     ( RandomSupply.hs, interpreted )
Ok, modules loaded: RandomSupply, Supply.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>(fst . runSupply next) `fmap` randomsIO</code></strong>

&lt;interactive&gt;:1:17:
    Ambiguous occurrence `next'
    It could refer to either `Supply.next', imported from Supply at RandomSupply.hs:4:0-12
                                              (defined at Supply.hs:32:0)
                          or `System.Random.next', imported from System.Random
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>(fst . runSupply next) `fmap` randomsIO</code></strong>

&lt;interactive&gt;:1:17:
    Ambiguous occurrence `next'
    It could refer to either `Supply.next', imported from Supply at RandomSupply.hs:4:0-12
                                              (defined at Supply.hs:32:0)
                          or `System.Random.next', imported from System.Random
</pre><p id="x_Wr"><a name="x_Wr"></a>Recall that our <code class="function">runSupply</code> function
	returns both the result of executing the monadic action and
	the unconsumed remainder of the list.  Since we passed it an
	infinite list of random numbers, we compose with
	<code class="function">fst</code> to ensure that we don't get drowned
	in random numbers when <span class="command"><strong>ghci</strong></span> tries to print the
	result.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id647480">Another round of golf</h3></div></div></div><p id="x_Xr"><a name="x_Xr"></a>The pattern of applying a function to one element of a
	pair, and constructing a new pair with the other original
	element untouched, is common enough in Haskell code that it
	has been turned into standard code.</p><p id="x_Yr"><a name="x_Yr"></a>In the <code class="code">Control.Arrow</code> module are two
	functions, <code class="function">first</code> and
	<code class="function">second</code>, that perform this
	operation.</p><a name="randomSupply.ghci:first"></a><pre id="randomSupply.ghci:first" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +Control.Arrow</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>first (+3) (1,2)</code></strong>
(4,2)
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>second odd ('a',1)</code></strong>
('a',True)
</pre><p id="x_Zr"><a name="x_Zr"></a>(Indeed, we already encountered
	<code class="function">second</code>, in <a class="xref" href="using-typeclasses.html#jsonclass.instances" title="JSON typeclasses without overlapping instances">the section called “JSON typeclasses without overlapping instances”</a>.)  We can use
	<code class="function">first</code> to golf our definition of
	<code class="function">randomsIO</code>, turning it into a
	one-liner.</p><a name="RandomGolf.hs:randomsIO_golfed"></a><pre id="RandomGolf.hs:randomsIO_golfed" class="programlisting">-- file: ch15/RandomGolf.hs
import Control.Arrow (first)

randomsIO_golfed :: Random a =&gt; IO [a]
randomsIO_golfed = getStdRandom (first randoms . split)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id647603">Separating interface from implementation</h2></div></div></div><p id="x_ar"><a name="x_ar"></a>In the previous section, we saw how to hide the fact that
      we're using a <span class="type">State</span> monad to hold the state for our
      <span class="type">Supply</span> monad.</p><p id="x_br"><a name="x_br"></a>Another important way to make code more modular involves
      separating its <span class="emphasis"><em>interface</em></span>—what the
      code can do—from its
      <span class="emphasis"><em>implementation</em></span>—how it does
      it.</p><p id="x_cr"><a name="x_cr"></a>The standard random number generator in
      <code class="code">System.Random</code> is known to be quite slow. If we use
      our <code class="function">randomsIO</code> function to provide it with
      random numbers, then our <code class="function">next</code> action will
      not perform well.</p><p id="x_dr"><a name="x_dr"></a>One simple and effective way that we could deal with this is
      to provide <span class="type">Supply</span> with a better source of random
      numbers.  Let's set this idea aside, though, and consider an
      alternative approach, one that is useful in many settings.  We
      will separate the actions we can perform with the monad from how
      it works using a typeclass.</p><a name="SupplyClass.hs:class"></a><pre id="SupplyClass.hs:class" class="programlisting">-- file: ch15/SupplyClass.hs
class (Monad m) =&gt; MonadSupply s m | m -&gt; s where
    next :: m (Maybe s)</pre><p id="x_er"><a name="x_er"></a>This typeclass defines the interface that any
      supply monad must implement. It bears careful inspection, since it
      uses several unfamiliar Haskell language extensions.  We will
      cover each one in the sections that follow.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="monadcase.mptc">Multi-parameter typeclasses</h3></div></div></div><p id="x_fr"><a name="x_fr"></a>How should we read the snippet <code class="code">MonadSupply s
	  m</code> in the typeclass?  If we add parentheses, an
	equivalent expression is <code class="code">(MonadSupply s) m</code>, which
	is a little clearer.  In other words, given some type variable
	<code class="varname">m</code> that is a <span class="type">Monad</span>, we can make
	it an instance of the typeclass <span class="type">MonadSupply s</span>.
	unlike a regular typeclass, this one has a
	<span class="emphasis"><em>parameter</em></span>.</p><p id="x_gr"><a name="x_gr"></a>As this language extension allows a typeclass to
	have more than one parameter, its name is
	<code class="code">MultiParamTypeClasses</code>.  The parameter
	<code class="varname">s</code> serves the same purpose as the
	<span class="type">Supply</span> type's parameter of the same name: it
	represents the type of the values handed out by the
	<code class="function">next</code> function.</p><p id="x_hr"><a name="x_hr"></a>Notice that we don't need to mention <code class="function">(&gt;&gt;=)</code> or
	<code class="literal">return</code> in the definition of <span class="type">MonadSupply s</span>,
	since the type class's context (superclass) requires that a
	<span class="type">MonadSupply s</span> must already be a
	<span class="type">Monad</span>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id647796">Functional dependencies</h3></div></div></div><p id="x_ir"><a name="x_ir"></a>To revisit a snippet that we ignored earlier, <code class="code">| m
	  -&gt; s</code> is a <span class="emphasis"><em>functional
	  dependency</em></span>, often called a
	<span class="emphasis"><em>fundep</em></span>.  We can read the vertical bar
	<code class="code">|</code> as “<span class="quote">such that</span>”, and the arrow
	<code class="code">-&gt;</code> as “<span class="quote">uniquely determines</span>”.  Our
	functional dependency establishes a
	<span class="emphasis"><em>relationship</em></span> between <code class="varname">m</code>
	and <code class="varname">s</code>.</p><p id="x_jr"><a name="x_jr"></a>The availability of functional dependencies is governed by
	the <code class="code">FunctionalDependencies</code> language pragma.</p><p id="x_kr"><a name="x_kr"></a>The purpose behind us declaring a relationship is to help
	the type checker.  Recall that a Haskell type checker is
	essentially a theorem prover, and that it is conservative in
	how it operates: it insists that its proofs must terminate. A
	non-terminating proof results in the compiler either giving up
	or getting stuck in an infinite loop.</p><p id="x_lr"><a name="x_lr"></a>With our functional dependency, we are telling the type
	checker that every time it sees some monad
	<code class="varname">m</code> being used in the context of a
	<span class="type">MonadSupply s</span>, the type <code class="varname">s</code> is
	the only acceptable type to use with it.  If we were to omit
	the functional dependency, the type checker would simply give
	up with an error message.</p><p id="x_mr"><a name="x_mr"></a>It's hard to picture what the relationship between
	<code class="varname">m</code> and <code class="varname">s</code> really means, so
	let's look at an instance of this typeclass.</p><a name="SupplyClass.hs:instance"></a><pre id="SupplyClass.hs:instance" class="programlisting">-- file: ch15/SupplyClass.hs
import qualified Supply as S

instance MonadSupply s (S.Supply s) where
    next = S.next</pre><p id="x_nr"><a name="x_nr"></a>Here, the type variable <code class="varname">m</code> is replaced
	by the type <span class="type">S.Supply s</span>.  Thanks to our functional
	dependency, the type checker now knows that when it sees a
	type <span class="type">S.Supply s</span>, the type can be used as an
	instance of the typeclass <span class="type">MonadSupply s</span>.</p><p id="x_or"><a name="x_or"></a>If we didn't have a functional dependency, the type
	checker would not be able to figure out the relationship
	between the type parameter of the class <span class="type">MonadSupply
	  s</span> and that of the type <span class="type">Supply s</span>, and it
	would abort compilation with an error.  The definition itself
	would compile; the type error would not arise until the first
	time we tried to use it.</p><p id="x_pr"><a name="x_pr"></a>To strip away one final layer of abstraction, consider the
	type <span class="type">S.Supply Int</span>.  Without a functional
	dependency, we could declare this an instance of
	<span class="type">MonadSupply s</span>.  However, if we tried to write
	code using this instance, the compiler would not be able to
	figure out that the type's <span class="type">Int</span> parameter needs to
	be the same as the typeclass's <code class="varname">s</code>
	parameter, and it would report an error.</p><p id="x_qr"><a name="x_qr"></a>Functional dependencies can be tricky to understand, and
	once we move beyond simple uses, they often prove difficult to
	work with in practice.  Fortunately, the most frequent use of
	functional dependencies is in situations as simple as ours,
	where they cause little trouble.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id647987">Rounding out our module</h3></div></div></div><p id="x_rr"><a name="x_rr"></a>If we save our typeclass and instance in a source file
	named <code class="filename">SupplyClass.hs</code>, we'll need to add
	a module header such as the following.</p><a name="SupplyClass.hs:module"></a><pre id="SupplyClass.hs:module" class="programlisting">-- file: ch15/SupplyClass.hs
{-# LANGUAGE FlexibleInstances, FunctionalDependencies,
             MultiParamTypeClasses #-}

module SupplyClass
    (
      MonadSupply(..)
    , S.Supply
    , S.runSupply
    ) where</pre><p id="x_sr"><a name="x_sr"></a>The <code class="code">FlexibleInstances</code> extension is necessary
	so that the compiler will accept our instance declaration.
	This extension relaxes the normal rules for writing instances
	in some circumstances, in a way that still lets the compiler's
	type checker guarantee that it will terminate.  Our need for
	<code class="code">FlexibleInstances</code> here is caused by our use of
	functional dependencies, but the details are unfortunately
	beyond the scope of this book.</p><div class="tip"><table border="0" summary="Tip: How to know when a language extension is needed"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="/support/figs/tip.png"></td><th align="left">How to know when a language extension is needed</th></tr><tr><td align="left" valign="top"><p id="x_tr"><a name="x_tr"></a>If <span class="application">GHC</span> cannot compile a piece of code because it would
	  require some language extension to be enabled, it will tell
	  us which extension we should use.  For example, if it
	  decides that our code needs flexible instance support, it
	  will suggest that we try compiling with the
	  <code class="option">-XFlexibleInstances</code> option.  A
	  <code class="option">-X</code> option has the same effect as a
	  <code class="code">LANGUAGE</code> directive: it enables a particular
	  extension.</p></td></tr></table></div><p id="x_ur"><a name="x_ur"></a>Finally, notice that we're re-exporting the
	<code class="function">runSupply</code> and <span class="type">Supply</span> names
	from this module. It's perfectly legal to export a name from
	one module even though it's defined in another.  In our case,
	it means that client code only needs to import the
	<code class="code">SupplyClass</code> module, without also importing the
	<code class="code">Supply</code> module.  This reduces the number of
	“<span class="quote">moving parts</span>” that a user of our code needs to
	keep in mind.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id648100">Programming to a monad's interface</h3></div></div></div><p id="x_tG1"><a name="x_tG1"></a>Here is a simple function that fetches two values from
	our <span class="type">Supply</span> monad, formats them as a string, and
	returns them.</p><a name="Supply.hs:showTwo"></a><pre id="Supply.hs:showTwo" class="programlisting">-- file: ch15/Supply.hs
showTwo :: (Show s) =&gt; Supply s String
showTwo = do
  a &lt;- next
  b &lt;- next
  return (show "a: " ++ show a ++ ", b: " ++ show b)</pre><p id="x_uG1"><a name="x_uG1"></a>This code is tied by its result type to our
	<span class="type">Supply</span> monad.  We can easily generalize to any
	monad that implements our <span class="type">MonadSupply</span> interface
	by modifying our function's type.  Notice that the body of the
	function remains unchanged.</p><a name="SupplyClass.hs:showTwo_class"></a><pre id="SupplyClass.hs:showTwo_class" class="programlisting">-- file: ch15/SupplyClass.hs
showTwo_class :: (Show s, Monad m, MonadSupply s m) =&gt; m String
showTwo_class = do
  a &lt;- next
  b &lt;- next
  return (show "a: " ++ show a ++ ", b: " ++ show b)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id648161">The reader monad</h2></div></div></div><p id="x_wr"><a name="x_wr"></a>The <span class="type">State</span> monad lets us plumb a piece of
      mutable state through our code.  Sometimes, we would like to be
      able to pass some <span class="emphasis"><em>immutable</em></span> state around,
      such as a program's configuration data.  We could use the
      <span class="type">State</span> monad for this purpose, but we could then
      find ourselves accidentally modifying data that should remain
      unchanged.</p><p id="x_xr"><a name="x_xr"></a>Let's forget about monads for a moment and think about what
      a <span class="emphasis"><em>function</em></span> with our desired characteristics
      ought to do.  It should accept a value of some type <code class="varname">e</code> (for <span class="emphasis"><em>environment</em></span>)
	that represents the data
      that we're passing in, and return a value of some
      other type <code class="varname">a</code> as its result.  The
      overall type we want is <span class="type">e -&gt; a</span>.</p><p id="x_yr"><a name="x_yr"></a>To turn this type into a convenient <span class="type">Monad</span>
      instance, we'll wrap it in a <code class="code">newtype</code>.</p><a name="SupplyInstance.hs:Reader"></a><pre id="SupplyInstance.hs:Reader" class="programlisting">-- file: ch15/SupplyInstance.hs
newtype Reader e a = R { runReader :: e -&gt; a }</pre><p id="x_zr"><a name="x_zr"></a>Making this into a <span class="type">Monad</span> instance doesn't take
      much work.</p><a name="SupplyInstance.hs:Monad"></a><pre id="SupplyInstance.hs:Monad" class="programlisting">-- file: ch15/SupplyInstance.hs
instance Monad (Reader e) where
    return a = R $ \_ -&gt; a
    m &gt;&gt;= k = R $ \r -&gt; runReader (k (runReader m r)) r</pre><p id="x_As"><a name="x_As"></a>We can think of our value of type <code class="varname">e</code> as an <span class="emphasis"><em>environment</em></span>
      in which we're evaluating some expression.  The <code class="literal">return</code> action
      should have the same effect no matter what the environment is,
      so our version ignores its environment.</p><p id="x_Bs"><a name="x_Bs"></a>Our definition of <code class="function">(&gt;&gt;=)</code> is a little more complicated, but
      only because we have to make the environment—here the
      variable <code class="varname">r</code>—available both in the
      current computation and in the computation we're chaining
      into.</p><p id="x_Cs"><a name="x_Cs"></a>How does a piece of code executing in this monad find out
      what's in its environment?  It simply has to
      <code class="function">ask</code>.</p><a name="SupplyInstance.hs:ask"></a><pre id="SupplyInstance.hs:ask" class="programlisting">-- file: ch15/SupplyInstance.hs
ask :: Reader e e
ask = R id</pre><p id="x_Ds"><a name="x_Ds"></a>Within a given chain of actions, every invocation of
      <code class="function">ask</code>  will return the same value, since the
      value stored in the environment doesn't change.  Our code
      is easy to test in <span class="command"><strong>ghci</strong></span>.</p><a name="supply.ghci:instance"></a><pre id="supply.ghci:instance" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>runReader (ask &gt;&gt;= \x -&gt; return (x * 3)) 2</code></strong>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package random-1.0.0.0 ... linking ... done.
6
</pre><p id="x_Es"><a name="x_Es"></a>The <span class="type">Reader</span> monad is included in the standard
      <code class="code">mtl</code> library, which is usually bundled with <span class="application">GHC</span>.
      You can find it in the <code class="code">Control.Monad.Reader</code> module.
      The motivation for this monad may initially seem a little thin,
      because it is most often useful in complicated code.  We'll
      often need to access a piece of configuration information
      deep in the bowels of a program; passing that information in as
      a normal parameter would require a painful restructuring of our
      code.  By hiding this information in our monad's plumbing,
      intermediate functions that don't care about the configuration
      information don't need to see it.</p><p id="x_Fs"><a name="x_Fs"></a>The clearest motivation for the
      <span class="type">Reader</span> monad will come in <a class="xref" href="monad-transformers.html" title="Chapter 18. Monad transformers">Chapter 18, <i>Monad transformers</i></a>, when we discuss
      combining several monads to build a new monad.  There, we'll see
      how to gain finer control over state, so that our code can
      modify some values via the <span class="type">State</span> monad, while other
      values remain immutable, courtesy of the <span class="type">Reader</span>
      monad.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id648430">A return to automated deriving</h2></div></div></div><p id="x_Gs"><a name="x_Gs"></a>Now that we know about the <span class="type">Reader</span>
      monad, let's use it to create an instance of our
      <span class="type">MonadSupply</span> typeclass.  To keep our example simple,
      we'll violate the spirit of <span class="type">MonadSupply</span> here: our
      <code class="function">next</code> action will always return the same
      value, instead of always returning a different value.</p><p id="x_Hs"><a name="x_Hs"></a>It would be a bad idea to directly make the
      <span class="type">Reader</span> type an instance of the
      <span class="type">MonadSupply</span> class, because then
      <span class="emphasis"><em>any</em></span> <span class="type">Reader</span> could act as a
      <span class="type">MonadSupply</span>.  This would usually not make any
      sense.</p><p id="x_Is"><a name="x_Is"></a>Instead, we create a <code class="code">newtype</code> based on
      <span class="type">Reader</span>.  The <code class="code">newtype</code> hides the fact that we're
      using <span class="type">Reader</span> internally.  We must now make our type
      an instance of both of the typeclasses we care about.  With the
      <code class="code">GeneralizedNewtypeDeriving</code> extension enabled, <span class="application">GHC</span>
      will do most of the hard work for us.</p><a name="SupplyInstance.hs:MySupply"></a><pre id="SupplyInstance.hs:MySupply" class="programlisting">-- file: ch15/SupplyInstance.hs
newtype MySupply e a = MySupply { runMySupply :: Reader e a }
    deriving (Monad)

instance MonadSupply e (MySupply e) where
    next = MySupply $ do
             v &lt;- ask
             return (Just v)

    -- more concise:
    -- next = MySupply (Just `liftM` ask)</pre><p id="x_Js"><a name="x_Js"></a>Notice that we must make our type an instance of
      <span class="type">MonadSupply e</span>, not <span class="type">MonadSupply</span>.  If we
      omit the type variable, the compiler will complain.</p><p id="x_Ks"><a name="x_Ks"></a>To try out our <span class="type">MySupply</span> type, we'll first
      create a simple function that should work with any
      <span class="type">MonadSupply</span> instance.</p><a name="SupplyInstance.hs:xy"></a><pre id="SupplyInstance.hs:xy" class="programlisting">-- file: ch15/SupplyInstance.hs
xy :: (Num s, MonadSupply s m) =&gt; m s
xy = do
  Just x &lt;- next
  Just y &lt;- next
  return (x * y)</pre><p id="x_Ls"><a name="x_Ls"></a>If we use this with our <span class="type">Supply</span> monad and
      <code class="function">randomsIO</code> function, we get a different
      answer every time, as we expect.</p><a name="supply.ghci:xy1"></a><pre id="supply.ghci:xy1" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>(fst . runSupply xy) `fmap` randomsIO</code></strong>
-15697064270863081825448476392841917578
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>(fst . runSupply xy) `fmap` randomsIO</code></strong>
17182983444616834494257398042360119726
</pre><p id="x_Ms"><a name="x_Ms"></a>Because our <span class="type">MySupply</span> monad has two layers of
      <code class="code">newtype</code> wrapping, we can make it easier to use by writing a
      custom execution function for it.</p><a name="SupplyInstance.hs:runMS"></a><pre id="SupplyInstance.hs:runMS" class="programlisting">-- file: ch15/SupplyInstance.hs
runMS :: MySupply i a -&gt; i -&gt; a
runMS = runReader . runMySupply</pre><p id="x_Ns"><a name="x_Ns"></a>When we apply our <code class="function">xy</code> action
      using this execution function, we get the same answer every
      time.  Our code remains the same, but because we are executing
      it in a different implementation of <span class="type">MonadSupply</span>,
      its behavior has changed.</p><a name="supply.ghci:xy2"></a><pre id="supply.ghci:xy2" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>runMS xy 2</code></strong>
4
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runMS xy 2</code></strong>
4
</pre><p id="x_Os"><a name="x_Os"></a>Like our <span class="type">MonadSupply</span> typeclass and
      <span class="type">Supply</span> monad, almost all of the common Haskell
      monads are built with a split between interface and
      implementation.  For example, the <code class="function">get</code> and
      <code class="function">put</code> functions that we introduced as
      “<span class="quote">belonging to</span>” the <span class="type">State</span> monad are
      actually methods of the <span class="type">MonadState</span> typeclass; the
      <span class="type">State</span> type is an instance of this class.</p><p id="x_Ps"><a name="x_Ps"></a>Similarly, the standard <span class="type">Reader</span> monad is an
      instance of the <span class="type">MonadReader</span> typeclass, which
      specifies the <code class="function">ask</code> method.</p><p id="x_Qs"><a name="x_Qs"></a>While the separation of interface and implementation that
      we've discussed above is appealing for its architectural
      cleanliness, it has important practical applications that will
      become clearer later. When we start combining monads in <a class="xref" href="monad-transformers.html" title="Chapter 18. Monad transformers">Chapter 18, <i>Monad transformers</i></a>, we will save a lot of effort through the use of
      <code class="code">GeneralizedNewtypeDeriving</code> and typeclasses.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="id648782">Hiding the IO monad</h2></div></div></div><p id="x_Rs"><a name="x_Rs"></a>The blessing and curse of the <span class="type">IO</span> monad is that
      it is extremely powerful.  If we believe that careful use of
      types helps us to avoid programming mistakes, then the
      <span class="type">IO</span> monad should be a great source of unease.
      Because the <span class="type">IO</span> monad imposes no restrictions on
      what we can do, it leaves us vulnerable to all kinds of
      accidents.</p><p id="x_Ss"><a name="x_Ss"></a>How can we tame its power?  Let's say that we would like to
      guarantee to ourselves that a piece of code can read and write
      files on the local filesystem, but that it will not access the
      network.  We can't use the plain <span class="type">IO</span> monad, because
      it won't restrict us.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id648821">Using a newtype</h3></div></div></div><p id="x_Ts"><a name="x_Ts"></a>Let's create a module that provides a small set of
	functionality for reading and writing files.</p><a name="HandleIO.hs:module"></a><pre id="HandleIO.hs:module" class="programlisting">-- file: ch15/HandleIO.hs
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module HandleIO
    (
      HandleIO
    , Handle
    , IOMode(..)
    , runHandleIO
    , openFile
    , hClose
    , hPutStrLn
    ) where
    
import System.IO (Handle, IOMode(..))
import qualified System.IO</pre><p id="x_Us"><a name="x_Us"></a>Our first approach to creating a restricted version of
	<span class="type">IO</span> is to wrap it with a <code class="code">newtype</code>.</p><a name="HandleIO.hs:newtype"></a><pre id="HandleIO.hs:newtype" class="programlisting">-- file: ch15/HandleIO.hs
newtype HandleIO a = HandleIO { runHandleIO :: IO a }
    deriving (Monad)</pre><p id="x_Vs"><a name="x_Vs"></a>We do the by-now familiar trick of exporting the type
	constructor and the <code class="function">runHandleIO</code> execution
	function from our module, but not the data constructor.  This
	will prevent code running within the <span class="type">HandleIO</span>
	monad from getting hold of the <span class="type">IO</span> monad that it
	wraps.</p><p id="x_Ws"><a name="x_Ws"></a>All that remains is for us to wrap each of the actions we
	want our monad to allow.  This is a simple matter of wrapping
	each <span class="type">IO</span> with a <span class="type">HandleIO</span> data
	constructor.</p><a name="HandleIO.hs:actions"></a><pre id="HandleIO.hs:actions" class="programlisting">-- file: ch15/HandleIO.hs
openFile :: FilePath -&gt; IOMode -&gt; HandleIO Handle
openFile path mode = HandleIO (System.IO.openFile path mode)

hClose :: Handle -&gt; HandleIO ()
hClose = HandleIO . System.IO.hClose

hPutStrLn :: Handle -&gt; String -&gt; HandleIO ()
hPutStrLn h s = HandleIO (System.IO.hPutStrLn h s)</pre><p id="x_Xs"><a name="x_Xs"></a>We can now use our restricted <span class="type">HandleIO</span> monad
	to perform I/O.</p><a name="HandleIO.hs:safeHello"></a><pre id="HandleIO.hs:safeHello" class="programlisting">-- file: ch15/HandleIO.hs
safeHello :: FilePath -&gt; HandleIO ()
safeHello path = do
  h &lt;- openFile path WriteMode
  hPutStrLn h "hello world"
  hClose h</pre><p id="x_Ys"><a name="x_Ys"></a>To run this action, we use
	<code class="function">runHandleIO</code>.</p><a name="handleIO.ghci:HandleIO"></a><pre id="handleIO.ghci:HandleIO" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:load HandleIO</code></strong>
[1 of 1] Compiling HandleIO         ( HandleIO.hs, interpreted )
Ok, modules loaded: HandleIO.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runHandleIO (safeHello "hello_world_101.txt")</code></strong>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package filepath-1.1.0.0 ... linking ... done.
Loading package directory-1.0.0.0 ... linking ... done.
Loading package mtl-1.1.0.0 ... linking ... done.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +System.Directory</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>removeFile "hello_world_101.txt"</code></strong>
</pre><p id="x_Zs"><a name="x_Zs"></a>If we try to sequence an action that runs in the
	<span class="type">HandleIO</span> monad with one that is not permitted,
	the type system forbids it.</p><a name="handleIO.ghci:bad"></a><pre id="handleIO.ghci:bad" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>runHandleIO (safeHello "goodbye" &gt;&gt; removeFile "goodbye")</code></strong>

&lt;interactive&gt;:1:36:
    Couldn't match expected type `HandleIO a'
           against inferred type `IO ()'
    In the second argument of `(&gt;&gt;)', namely `removeFile "goodbye"'
    In the first argument of `runHandleIO', namely
        `(safeHello "goodbye" &gt;&gt; removeFile "goodbye")'
    In the expression:
        runHandleIO (safeHello "goodbye" &gt;&gt; removeFile "goodbye")
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id649049">Designing for unexpected uses</h3></div></div></div><p id="x_as"><a name="x_as"></a>There's one small, but significant, problem with our
	<span class="type">HandleIO</span> monad: it doesn't take into account the
	possibility that we might occasionally need an escape hatch.
	If we define a monad like this, it is likely that we will
	occasionally need to perform an I/O action that isn't allowed
	for by the design of our monad.</p><p id="x_bs"><a name="x_bs"></a>Our purpose in defining a monad like this is to make it
	easier for us to write solid code in the common case, not to
	make corner cases impossible.   Let's thus give ourselves a
	way out.</p><p id="x_cs"><a name="x_cs"></a>The <code class="code">Control.Monad.Trans</code> module defines a
	“<span class="quote">standard escape hatch</span>”, the <span class="type">MonadIO</span>
	typeclass.  This defines a single function,
	<code class="function">liftIO</code>, which lets us embed an
	<span class="type">IO</span> action in another monad.</p><a name="monadio.ghci:MonadIO"></a><pre id="monadio.ghci:MonadIO" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +Control.Monad.Trans</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:info MonadIO</code></strong>
class (Monad m) =&gt; MonadIO m where liftIO :: IO a -&gt; m a
  	-- Defined in Control.Monad.Trans
instance MonadIO IO -- Defined in Control.Monad.Trans
</pre><p id="x_ds"><a name="x_ds"></a>Our implementation of this typeclass is trivial: we just
	wrap <span class="type">IO</span> with our data constructor.</p><a name="HandleIO.hs:MonadIO"></a><pre id="HandleIO.hs:MonadIO" class="programlisting">-- file: ch15/HandleIO.hs
import Control.Monad.Trans (MonadIO(..))

instance MonadIO HandleIO where
    liftIO = HandleIO</pre><p id="x_es"><a name="x_es"></a>With judicious use of <code class="function">liftIO</code>, we can
	escape our shackles and invoke <span class="type">IO</span> actions where
	necessary.</p><a name="HandleIO.hs:tidyHello"></a><pre id="HandleIO.hs:tidyHello" class="programlisting">-- file: ch15/HandleIO.hs
tidyHello :: FilePath -&gt; HandleIO ()
tidyHello path = do
  safeHello path
  liftIO (removeFile path)</pre><div class="tip"><table border="0" summary="Tip: Automatic derivation and MonadIO"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="/support/figs/tip.png"></td><th align="left">Automatic derivation and MonadIO</th></tr><tr><td align="left" valign="top"><p id="x_fs"><a name="x_fs"></a>We could have had the compiler automatically derive an
	  instance of <span class="type">MonadIO</span> for us by adding the type
	  class to the <code class="code">deriving</code> clause of
	  <span class="type">HandleIO</span>.  In fact, in production code, this
	  would be our usual strategy.  We avoided that here simply to
	  separate the presentation of the earlier material from that
	  of <span class="type">MonadIO</span>.</p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="monadcase.io.class">Using typeclasses</h3></div></div></div><p id="x_gs"><a name="x_gs"></a>The disadvantage of hiding <span class="type">IO</span> in another
	monad is that we're still tied to a concrete implementation.
	If we want to swap <span class="type">HandleIO</span> for some other monad,
	we must change the type of every action that uses
	<span class="type">HandleIO</span>.</p><p id="x_hs"><a name="x_hs"></a>As an alternative, we can create a typeclass that
	specifies the interface we want from a monad that manipulates
	files.</p><a name="MonadHandle.hs:MonadHandle"></a><pre id="MonadHandle.hs:MonadHandle" class="programlisting">-- file: ch15/MonadHandle.hs
{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}

module MonadHandle (MonadHandle(..)) where

import System.IO (IOMode(..))

class Monad m =&gt; MonadHandle h m | m -&gt; h where
    openFile :: FilePath -&gt; IOMode -&gt; m h
    hPutStr :: h -&gt; String -&gt; m ()
    hClose :: h -&gt; m ()
    hGetContents :: h -&gt; m String

    hPutStrLn :: h -&gt; String -&gt; m ()
    hPutStrLn h s = hPutStr h s &gt;&gt; hPutStr h "\n"</pre><p id="x_is"><a name="x_is"></a>Here, we've chosen to abstract away both the type of the
	monad and the type of a file handle.  To satisfy the type
	checker, we've added a functional dependency: for any instance
	of <span class="type">MonadHandle</span>, there is exactly one handle type
	that we can use.  When we make the <span class="type">IO</span> monad an
	instance of this class, we use a regular
	<span class="type">Handle</span>.</p><a name="MonadHandleIO.hs:IO"></a><pre id="MonadHandleIO.hs:IO" class="programlisting">-- file: ch15/MonadHandleIO.hs
{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}

import MonadHandle
import qualified System.IO

import System.IO (IOMode(..))
import Control.Monad.Trans (MonadIO(..), MonadTrans(..))
import System.Directory (removeFile)

import SafeHello

instance MonadHandle System.IO.Handle IO where
    openFile = System.IO.openFile
    hPutStr = System.IO.hPutStr
    hClose = System.IO.hClose
    hGetContents = System.IO.hGetContents
    hPutStrLn = System.IO.hPutStrLn</pre><p id="x_js"><a name="x_js"></a>Because any <span class="type">MonadHandle</span> must also be a
	<span class="type">Monad</span>, we can write code that manipulates files
	using normal <code class="literal">do</code> notation, without caring what monad it will
	finally execute in.</p><a name="SafeHello.hs:safeHello"></a><pre id="SafeHello.hs:safeHello" class="programlisting">-- file: ch15/SafeHello.hs
safeHello :: MonadHandle h m =&gt; FilePath -&gt; m ()
safeHello path = do
  h &lt;- openFile path WriteMode
  hPutStrLn h "hello world"
  hClose h</pre><p id="x_ks"><a name="x_ks"></a>Because we made <span class="type">IO</span> an instance of this type
	class, we can execute this action from <span class="command"><strong>ghci</strong></span>.</p><a name="monadHandle.ghci:IO"></a><pre id="monadHandle.ghci:IO" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>safeHello "hello to my fans in domestic surveillance"</code></strong>
Loading package old-locale-1.0.0.0 ... linking ... done.
Loading package old-time-1.0.0.0 ... linking ... done.
Loading package filepath-1.1.0.0 ... linking ... done.
Loading package directory-1.0.0.0 ... linking ... done.
Loading package mtl-1.1.0.0 ... linking ... done.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>removeFile "hello to my fans in domestic surveillance"</code></strong>
</pre><p id="x_ls"><a name="x_ls"></a>The beauty of the typeclass approach is that we
	can swap one underlying monad for another without touching
	much code, as most of our code doesn't know or care about the
	implementation. For instance, we could replace <span class="type">IO</span>
	with a monad that compresses files as it writes them
	out.</p><p id="x_vG1"><a name="x_vG1"></a>Defining a monad's interface through a typeclass has a
	further benefit.  It lets other people hide our implementation
	in a <code class="code">newtype</code> wrapper, and automatically derive instances of
	just the typeclasses they want to expose.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id649416">Isolation and testing</h3></div></div></div><p id="x_ms"><a name="x_ms"></a>In fact, because our <code class="function">safeHello</code>
	function doesn't use the <span class="type">IO</span> type, we can even use
	a monad that <span class="emphasis"><em>can't</em></span> perform I/O.  This
	allows us to test code that would normally have side effects
	in a completely pure, controlled environment.</p><p id="x_ns"><a name="x_ns"></a>To do this, we will create a monad that doesn't perform
	I/O, but instead logs every file-related event for later
	processing.</p><a name="WriterIO.hs:Event"></a><pre id="WriterIO.hs:Event" class="programlisting">-- file: ch15/WriterIO.hs
data Event = Open FilePath IOMode
           | Put String String
           | Close String
           | GetContents String
             deriving (Show)</pre><p id="x_os"><a name="x_os"></a>Although we already developed a <span class="type">Logger</span> type
	in <a class="xref" href="monads.html#monads.logger" title="Using a new monad: show your work!">the section called “Using a new monad: show your work!”</a>, here we'll use the
	standard, and more general, <span class="type">Writer</span> monad. Like
	other <code class="code">mtl</code> monads, the API provided by
	<span class="type">Writer</span> is defined in a typeclass, in this case
	<span class="type">MonadWriter</span>.  Its most useful method is
	<code class="function">tell</code>, which logs a value.</p><a name="monadwriter.ghci:tell"></a><pre id="monadwriter.ghci:tell" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:m +Control.Monad.Writer</code></strong>
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>:type tell</code></strong>
tell :: (MonadWriter w m) =&gt; w -&gt; m ()
</pre><p id="x_ps"><a name="x_ps"></a>The values we log can be of any <span class="type">Monoid</span> type.
	Since the list type is a <span class="type">Monoid</span>, we'll log to a
	list of <span class="type">Event</span>.</p><p id="x_qs"><a name="x_qs"></a>We could make <span class="type">Writer [Event]</span> an instance of
	<span class="type">MonadHandle</span>, but it's cheap, easy, and safer to
	make a special-purpose monad.</p><a name="WriterIO.hs:WriterIO"></a><pre id="WriterIO.hs:WriterIO" class="programlisting">-- file: ch15/WriterIO.hs
newtype WriterIO a = W { runW :: Writer [Event] a }
    deriving (Monad, MonadWriter [Event])</pre><p id="x_rs"><a name="x_rs"></a>Our execution function simply removes the <code class="code">newtype</code>
	wrapper we added, then calls the normal <span class="type">Writer</span>
	monad's execution function.</p><a name="WriterIO.hs:runWriterIO"></a><pre id="WriterIO.hs:runWriterIO" class="programlisting">-- file: ch15/WriterIO.hs
runWriterIO :: WriterIO a -&gt; (a, [Event])
runWriterIO = runWriter . runW</pre><p id="x_ss"><a name="x_ss"></a>When we try this code out in <span class="command"><strong>ghci</strong></span>, it gives us a log of
	the function's file activities.</p><a name="monadHandle.ghci:Writer"></a><pre id="monadHandle.ghci:Writer" class="screen"><code class="prompt">ghci&gt; </code><strong class="userinput"><code>:load WriterIO</code></strong>
[1 of 3] Compiling MonadHandle      ( MonadHandle.hs, interpreted )
[2 of 3] Compiling SafeHello        ( SafeHello.hs, interpreted )
[3 of 3] Compiling WriterIO         ( WriterIO.hs, interpreted )
Ok, modules loaded: SafeHello, MonadHandle, WriterIO.
<code class="prompt">ghci&gt; </code><strong class="userinput"><code>runWriterIO (safeHello "foo")</code></strong>
((),[Open "foo" WriteMode,Put "foo" "hello world",Put "foo" "\n",Close "foo"])
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="monadcase.writer.dlist">The writer monad and lists</h3></div></div></div><p id="x_ts"><a name="x_ts"></a>The writer monad uses the monoid's
	<code class="function">mappend</code> function every time we use
	<code class="function">tell</code>.  Because
	<code class="function">mappend</code> for lists is
	<code class="function">(++)</code>, lists are not a good practical
	choice for use with <span class="type">Writer</span>: repeated appends are
	expensive.  We use lists above purely for
	simplicity.</p><p id="x_us"><a name="x_us"></a>In production code, if you want to use the
	<span class="type">Writer</span> monad and you need list-like behaviour,
	use a type with better  append characteristics. One such type
	is the difference list, which we introduced in <a class="xref" href="data-structures.html#data.dlist" title="Taking advantage of functions as data">the section called “Taking advantage of functions as data”</a>.  You don't need to roll your own
	difference list implementation: a well tuned library is
	available for download from Hackage, the Haskell package
	database.  Alternatively, you can use the <span class="type">Seq</span>
	type from the <code class="code">Data.Sequence</code> module, which we
	introduced in <a class="xref" href="data-structures.html#data.seq" title="General purpose sequences">the section called “General purpose sequences”</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id649728">Arbitrary I/O revisited</h3></div></div></div><p id="x_vs"><a name="x_vs"></a>If we use the typeclass approach to restricting
	<span class="type">IO</span>, we may still want to retain the ability to
	perform arbitrary I/O actions.  We might try adding
	<span class="type">MonadIO</span> as a constraint on our typeclass.</p><a name="MonadHandleIO.hs:tidierHello"></a><pre id="MonadHandleIO.hs:tidierHello" class="programlisting">-- file: ch15/MonadHandleIO.hs
class (MonadHandle h m, MonadIO m) =&gt; MonadHandleIO h m | m -&gt; h

instance MonadHandleIO System.IO.Handle IO

tidierHello :: (MonadHandleIO h m) =&gt; FilePath -&gt; m ()
tidierHello path = do
  safeHello path
  liftIO (removeFile path)</pre><p id="x_ws"><a name="x_ws"></a>This approach has a problem, though: the added
	<span class="type">MonadIO</span> constraint loses us the ability to test
	our code in a pure environment, because we can no longer tell
	whether a test might have damaging side effects.  The
	alternative is to move this constraint from the typeclass,
	where it “<span class="quote">infects</span>” all functions, to only those
	functions that really need to perform I/O.</p><a name="MonadHandleIO.hs:tidyHello"></a><pre id="MonadHandleIO.hs:tidyHello" class="programlisting">-- file: ch15/MonadHandleIO.hs
tidyHello :: (MonadIO m, MonadHandle h m) =&gt; FilePath -&gt; m ()
tidyHello path = do
  safeHello path
  liftIO (removeFile path)</pre><p id="x_xs"><a name="x_xs"></a>We can use pure property tests on the functions that lack
	<span class="type">MonadIO</span> constraints, and traditional unit tests
	on the rest.</p><p id="x_ys"><a name="x_ys"></a>Unfortunately, we've substituted one problem for another:
	we can't invoke code with both <span class="type">MonadIO</span> and
	<span class="type">MonadHandle</span> constraints from code that has the
	<span class="type">MonadHandle</span> constraint alone.  If we find that
	somewhere deep in our <span class="type">MonadHandle</span>-only code, we
	really need the <span class="type">MonadIO</span> constraint, we must add
	it to all the code paths that lead to this point.</p><p id="x_zs"><a name="x_zs"></a>Allowing arbitrary I/O is risky, and has a profound effect
	on how we develop and test our code.  When we have to choose
	between being permissive on the one hand, and easier reasoning
	and testing on the other, we usually opt for the
	latter.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title" id="id649843">Exercises</h3></div></div></div><div class="qandaset"><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id649850"></a><a name="id649853"></a><p><b>1.</b></p></td><td align="left" valign="top"><p id="x_At"><a name="x_At"></a>Using QuickCheck, write a test for an action in the
	      <span class="type">MonadHandle</span> monad, to see if it tries to
	      write to a file handle that is not open.  Try it
	      out on <code class="function">safeHello</code>.</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id649875"></a><a name="id649877"></a><p><b>2.</b></p></td><td align="left" valign="top"><p id="x_Bt"><a name="x_Bt"></a>Write an action that tries to write to a file handle
	      that it has closed.  Does your test catch this
	      bug?</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id649889"></a><a name="id649891"></a><p><b>3.</b></p></td><td align="left" valign="top"><p id="x_wG1"><a name="x_wG1"></a>In a form-encoded string, the same key may appear
	      several times, with or without values, e.g.
	      <code class="code">key&amp;key=1&amp;key=2</code>.  What type might
	      you use to represent the values associated with a key in
	      this sort of string?  Write a parser that correctly
	      captures all of the information.</p></td></tr></tbody></table></div></div></div></div><div class="rwhfooter"><p><img src="/support/figs/rss.png"> Want to stay up to date? Subscribe to the comment feed for <a id="chapterfeed" class="feed" href="/feeds/comments/">this chapter</a>, or the <a class="feed" href="/feeds/comments/">entire book</a>.</p><p>Copyright 2007, 2008 Bryan O'Sullivan, Don Stewart, and
      John Goerzen. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative
      Commons Attribution-Noncommercial 3.0 License</a>. Icons by <a href="mailto:mattahan@gmail.com">Paul Davey</a> aka <a href="http://mattahan.deviantart.com/">Mattahan</a>.</p></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="monads.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="using-parsec.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 14. Monads </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 16. Using Parsec</td></tr></table></div><script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">_uacct = "UA-1805907-3"; urchinTracker();</script></body></html>
